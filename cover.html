
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>port: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">MgApplication/core/port/response.go (100.0%)</option>
				
				<option value="file1">MgApplication/docs/docs.go (0.0%)</option>
				
				<option value="file2">MgApplication/handler/applications.go (69.0%)</option>
				
				<option value="file3">MgApplication/handler/bulksms.go (43.2%)</option>
				
				<option value="file4">MgApplication/handler/msgrequest.go (61.5%)</option>
				
				<option value="file5">MgApplication/handler/providers.go (70.8%)</option>
				
				<option value="file6">MgApplication/handler/reports.go (53.7%)</option>
				
				<option value="file7">MgApplication/handler/response.go (100.0%)</option>
				
				<option value="file8">MgApplication/handler/response/applications.go (100.0%)</option>
				
				<option value="file9">MgApplication/handler/response/bulksms.go (0.0%)</option>
				
				<option value="file10">MgApplication/handler/response/msgrequest.go (100.0%)</option>
				
				<option value="file11">MgApplication/handler/response/providers.go (85.7%)</option>
				
				<option value="file12">MgApplication/handler/response/reports.go (100.0%)</option>
				
				<option value="file13">MgApplication/handler/response/templates.go (100.0%)</option>
				
				<option value="file14">MgApplication/handler/templates.go (60.7%)</option>
				
				<option value="file15">MgApplication/handler/validator.go (76.9%)</option>
				
				<option value="file16">MgApplication/main.go (0.0%)</option>
				
				<option value="file17">MgApplication/repo/postgres/applications.go (67.6%)</option>
				
				<option value="file18">MgApplication/repo/postgres/bulksms.go (34.2%)</option>
				
				<option value="file19">MgApplication/repo/postgres/msgrequest.go (41.1%)</option>
				
				<option value="file20">MgApplication/repo/postgres/providers.go (70.5%)</option>
				
				<option value="file21">MgApplication/repo/postgres/reports.go (73.8%)</option>
				
				<option value="file22">MgApplication/repo/postgres/templates.go (53.9%)</option>
				
				<option value="file23">MgApplication/routes/routes.go (91.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package port

var (
        ListSuccess   StatusCodeAndMessage = StatusCodeAndMessage{StatusCode: 200, Message: "list retrieved successfully", Success: true}
        FetchSuccess  StatusCodeAndMessage = StatusCodeAndMessage{StatusCode: 200, Message: "data retrieved successfully", Success: true}
        CreateSuccess StatusCodeAndMessage = StatusCodeAndMessage{StatusCode: 201, Message: "resource created successfully", Success: true}
        UpdateSuccess StatusCodeAndMessage = StatusCodeAndMessage{StatusCode: 200, Message: "resource updated successfully", Success: true}
        DeleteSuccess StatusCodeAndMessage = StatusCodeAndMessage{StatusCode: 200, Message: "resource deleted successfully", Success: true}
)

type StatusCodeAndMessage struct {
        StatusCode int    `json:"status_code"`
        Success    bool   `json:"success"`
        Message    string `json:"message"`
}

type MetaDataResponse struct {
        Skip                 uint64 `json:"skip"`
        Limit                uint64 `json:"limit"`
        OrderBy              string `json:"order_by,omitempty"`
        SortType             string `json:"sort_type,omitempty"`
        TotalRecordsCount    int    `json:"total_records_count,omitempty"`
        ReturnedRecordsCount int    `json:"returned_records_count"`
}

func NewMetaDataResponse(skip uint64, limit uint64, total int) MetaDataResponse <span class="cov8" title="1">{
        return MetaDataResponse{
                Skip:                 skip,
                Limit:                limit,
                ReturnedRecordsCount: total,
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://cept.gov.in/terms",
        "contact": {
            "name": "API Support Team",
            "url": "http://cept.gov.in/support",
            "email": "support_cept@indiapost.gov.in"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/aggregate-sms-report": {
            "get": {
                "description": "Fetches SMS Aggregate report Applicationwise, Templatewise and Providerwise",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Reports"
                ],
                "summary": "Get Aggregate SMS Usage Report",
                "operationId": "AggregateSMSUsageReportHandler",
                "parameters": [
                    {
                        "type": "string",
                        "example": "01-01-2008",
                        "name": "from-date",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "orderBy",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "example": 1,
                        "name": "report-type",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "name": "skip",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "sortType",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "example": "18-06-2024",
                        "name": "to-date",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "SMS Aggregate report is retrieved",
                        "schema": {
                            "$ref": "#/definitions/response.AggregateSMSReportAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/applications": {
            "get": {
                "description": "Lists all message applications",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Applications"
                ],
                "summary": "Get Message Applications",
                "operationId": "ListMessageApplicationsHandler",
                "parameters": [
                    {
                        "type": "integer",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "orderBy",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "name": "skip",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "sortType",
                        "in": "query"
                    },
                    {
                        "type": "boolean",
                        "example": true,
                        "name": "status",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "All Message Applications are retrieved",
                        "schema": {
                            "$ref": "#/definitions/response.ListMsgApplicationsAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Creates a new message application",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Applications"
                ],
                "summary": "Creates a message application",
                "operationId": "CreateMessageApplicationHandler",
                "parameters": [
                    {
                        "description": "Creates Message Application",
                        "name": "createMessageApplicationRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.createMessageApplicationRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "New Message Application is created",
                        "schema": {
                            "$ref": "#/definitions/response.CreateMsgApplicationAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/applications/{application-id}": {
            "get": {
                "description": "Fetches Message Application by ApplicationID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Applications"
                ],
                "summary": "Get Message Application by ApplicationID",
                "operationId": "FetchApplicationHandler",
                "parameters": [
                    {
                        "type": "integer",
                        "example": 4,
                        "name": "application-id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Message Application is retrieved",
                        "schema": {
                            "$ref": "#/definitions/response.FetchMsgApplicationAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Allows editing of an existing Message Application",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Applications"
                ],
                "summary": "Edits an existing Message Application",
                "operationId": "UpdateMessageApplicationHandler",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Edit Message Application Request",
                        "name": "application-id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Edit Message Application Request",
                        "name": "updateMessageApplicationRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.updateMessageApplicationRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Message Application is modified",
                        "schema": {
                            "$ref": "#/definitions/response.UpdateMsgApplicationAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/applications/{application-id}/status": {
            "put": {
                "description": "Toggles the status of Message Application",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Applications"
                ],
                "summary": "Modifies the status of Message Application",
                "operationId": "ToggleApplicationStatusHandler",
                "parameters": [
                    {
                        "type": "integer",
                        "example": 4,
                        "name": "application-id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Message Application status is modified",
                        "schema": {
                            "$ref": "#/definitions/response.ToggleAppStatusAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/bulk-sms": {
            "post": {
                "description": "This API reads the output Excel file, constructs messages, and sends them to the NIC service in XML format.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "BulkSMS"
                ],
                "summary": "Send processed Excel file data",
                "operationId": "SendBulkSMSHandler",
                "parameters": [
                    {
                        "description": "Request Body",
                        "name": "sendBulkSMSRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/handler.sendBulkSMSRequest"
                            }
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Successful operation",
                        "schema": {
                            "$ref": "#/definitions/response.SendBulkSMSAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/bulk-sms-initiate": {
            "post": {
                "description": "Initiates sending of Bulk SMSes",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "BulkSMS"
                ],
                "summary": "Send Bulk SMSes",
                "operationId": "InitiateBulkSMSHandler",
                "parameters": [
                    {
                        "description": "Initiate Bulk SMS Request",
                        "name": "initiateBulkSMSRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.initiateBulkSMSRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Submitted successfully",
                        "schema": {
                            "$ref": "#/definitions/response.BulkSMSInitiateAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/bulk-sms-validate-otp": {
            "get": {
                "description": "Validates Test SMS",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "BulkSMS"
                ],
                "summary": "Validates Test SMS",
                "operationId": "ValidateTestSMSHandler",
                "parameters": [
                    {
                        "type": "string",
                        "example": "lnv579ejt2vmaq03i7up",
                        "name": "reference-id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "example": "906627",
                        "name": "test-string",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "True if validation succeeds, false otherwise",
                        "schema": {
                            "$ref": "#/definitions/response.ValidateBulkSMSOTPAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/sms-dashboard": {
            "get": {
                "description": "Fetches SMS Dashboard data",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Reports"
                ],
                "summary": "Get SMS Dashboard data",
                "operationId": "SMSDashboardHandler",
                "responses": {
                    "200": {
                        "description": "SMS Dashboard data is retrieved",
                        "schema": {
                            "$ref": "#/definitions/response.SMSDashboardAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/sms-providers": {
            "get": {
                "description": "Lists all message service providers",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Providers"
                ],
                "summary": "Get Message Providers",
                "operationId": "ListMessageProvidersHandler",
                "parameters": [
                    {
                        "type": "integer",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "orderBy",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "name": "skip",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "sortType",
                        "in": "query"
                    },
                    {
                        "type": "boolean",
                        "example": true,
                        "name": "status",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "All Message service providers are retrieved",
                        "schema": {
                            "$ref": "#/definitions/response.ListSMSProvidersAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Creates a new Message Service Provider",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Providers"
                ],
                "summary": "Creates a Message Service Provider",
                "operationId": "CreateMessageProviderHandler",
                "parameters": [
                    {
                        "description": "Create Message Service Provider",
                        "name": "createMessageProviderRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.createMessageProviderRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Message Service Provider is created",
                        "schema": {
                            "$ref": "#/definitions/response.CreateSMSProviderAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/sms-providers/{provider-id}": {
            "get": {
                "description": "Fetches Message Service Provider by ProviderID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Providers"
                ],
                "summary": "Get Message Service Provider by ProviderID",
                "operationId": "FetchMessageProviderHandler",
                "parameters": [
                    {
                        "type": "integer",
                        "example": 3,
                        "name": "provider-id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Message Provider is retrieved by ProviderID",
                        "schema": {
                            "$ref": "#/definitions/response.FetchSMSProviderAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Allows editing of an existing Message Provider",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Providers"
                ],
                "summary": "Edits an existing Message Provider",
                "operationId": "UpdateMessageProviderHandler",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Edit Message Provider Request",
                        "name": "provider-id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Edit Message Provider Request",
                        "name": "updateMessageProviderRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.updateMessageProviderRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Message Provider is modified",
                        "schema": {
                            "$ref": "#/definitions/response.UpdateSMSProviderAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/sms-providers/{provider-id}/status": {
            "put": {
                "description": "Toggles the status of Message Provider",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Providers"
                ],
                "summary": "Modifies the status of Message Provider",
                "operationId": "ToggleMessageProviderStatusHandler",
                "parameters": [
                    {
                        "type": "integer",
                        "example": 3,
                        "name": "provider-id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Message Provider status is modified",
                        "schema": {
                            "$ref": "#/definitions/response.ToggleProviderStatusAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/sms-request": {
            "post": {
                "description": "Creates message requests for application for registered templates",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "SMS Request"
                ],
                "summary": "Creates a message request",
                "operationId": "CreateSMSRequestHandler",
                "parameters": [
                    {
                        "description": "Creates Message request",
                        "name": "createSMSRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.createSMSRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/response.CreateSMSAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/sms-sent-status-report": {
            "get": {
                "description": "Fetches all SMS requests",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Reports"
                ],
                "summary": "Get all SMS requests",
                "operationId": "SentSMSStatusReportHandler",
                "parameters": [
                    {
                        "type": "string",
                        "example": "01-01-2008",
                        "name": "from-date",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "orderBy",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "name": "skip",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "sortType",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "example": "18-06-2024",
                        "name": "to-date",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "All message requests are retrieved",
                        "schema": {
                            "$ref": "#/definitions/response.SMSSentStatusReportAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/sms-templates": {
            "get": {
                "description": "Lists all message templates",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Templates"
                ],
                "summary": "Get all Message Templates",
                "operationId": "ListTemplatesHandler",
                "parameters": [
                    {
                        "type": "integer",
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "orderBy",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "name": "skip",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "name": "sortType",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "All Message Templates are retrieved",
                        "schema": {
                            "$ref": "#/definitions/response.ListTemplatesAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            },
            "post": {
                "description": "Creates a new Message template for message applications",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Templates"
                ],
                "summary": "Creates a new message template",
                "operationId": "CreateTemplateHandler",
                "parameters": [
                    {
                        "description": "Create new Message Template",
                        "name": "createTemplateRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.createTemplateRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Message Template is created",
                        "schema": {
                            "$ref": "#/definitions/response.CreateTemplateAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/sms-templates/details": {
            "get": {
                "description": "Fetch template details based on the provided query parameters such as TemplateLocalID, ApplicationID, and Templateformat.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Templates"
                ],
                "summary": "Get Template Details",
                "operationId": "FetchTemplateDetailsHandler",
                "parameters": [
                    {
                        "type": "string",
                        "example": "4",
                        "name": "application-id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "example": "Dear {#var#}, your {#var#} is scheduled on {#var#}. Pl check details over {#var#} - INDPOST",
                        "name": "template-format",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "example": 355,
                        "name": "template-local-id",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Fetched successfully",
                        "schema": {
                            "$ref": "#/definitions/response.FetchTemplateDetailsAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/sms-templates/name": {
            "get": {
                "description": "Fetches Message Template names by ApplicationID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Templates"
                ],
                "summary": "Get Message Template names by ApplicationID",
                "operationId": "FetchTemplateByApplicationHandler",
                "parameters": [
                    {
                        "type": "string",
                        "example": "4",
                        "name": "application-id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Message Template names are retrieved by ApplicationID",
                        "schema": {
                            "$ref": "#/definitions/response.FetchTemplateNameAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/sms-templates/{template-local-id}": {
            "get": {
                "description": "Fetches Message Template by TemplateLocalID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Templates"
                ],
                "summary": "Get Message Template by TemplateLocalID",
                "operationId": "FetchTemplateHandler",
                "parameters": [
                    {
                        "type": "integer",
                        "example": 355,
                        "name": "template-local-id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Message Template is retrieved by TemplateLocalID",
                        "schema": {
                            "$ref": "#/definitions/response.FetchTemplateAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            },
            "put": {
                "description": "Allows editing of an existing Message Template",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Templates"
                ],
                "summary": "Edits an existing Message Template",
                "operationId": "UpdateTemplateHandler",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "Edit Message Template Request",
                        "name": "template-local-id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Edit Message Template Request",
                        "name": "updateTemplateRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.updateTemplateRequest"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Message Template is modified",
                        "schema": {
                            "$ref": "#/definitions/response.UpdateTemplatesAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/sms-templates/{template-local-id}/status": {
            "put": {
                "description": "Modifies the status of Message Template",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Templates"
                ],
                "summary": "Modifies the status of Message Template",
                "operationId": "ToggleTemplateStatusHandler",
                "parameters": [
                    {
                        "type": "integer",
                        "example": 355,
                        "name": "template-local-id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "Message Template status is modified",
                        "schema": {
                            "$ref": "#/definitions/response.ToggleTemplateStatusAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        },
        "/test-sms-request": {
            "post": {
                "description": "Creates a new test message requests",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "SMS Request"
                ],
                "summary": "Creates a test message request",
                "operationId": "CreateTestSMSHandler",
                "parameters": [
                    {
                        "description": "Creates Message request",
                        "name": "createSMSRequest",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/handler.createTestSMSRequest"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Success",
                        "schema": {
                            "$ref": "#/definitions/response.TestSMSAPIResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "403": {
                        "description": "Forbidden",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "404": {
                        "description": "Data not found",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "409": {
                        "description": "Data conflict errpr",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "422": {
                        "description": "Binding or Validation error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "500": {
                        "description": "Internal server error",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "502": {
                        "description": "Bad Gateway",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    },
                    "504": {
                        "description": "Gateway Timeout",
                        "schema": {
                            "$ref": "#/definitions/apierrors.APIErrorResponse"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "apierrors.APIErrorResponse": {
            "type": "object",
            "properties": {
                "error": {
                    "$ref": "#/definitions/apierrors.AppError"
                },
                "message": {
                    "description": "Descriptive message providing details about the error.",
                    "type": "string"
                },
                "status_code": {
                    "description": "HTTP status code representing the error type (e.g., 404 for Not Found).",
                    "type": "integer"
                },
                "success": {
                    "description": "Success flag to indicate if the operation was successful.",
                    "type": "boolean"
                }
            }
        },
        "apierrors.AppError": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "field_errors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/apierrors.FieldError"
                    }
                },
                "id": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                }
            }
        },
        "apierrors.FieldError": {
            "type": "object",
            "properties": {
                "field": {
                    "type": "string"
                },
                "message": {
                    "type": "string"
                },
                "value": {}
            }
        },
        "handler.createMessageApplicationRequest": {
            "type": "object",
            "required": [
                "application_name",
                "request_type",
                "status"
            ],
            "properties": {
                "application_id": {
                    "type": "integer"
                },
                "application_name": {
                    "type": "string",
                    "example": "Test Application"
                },
                "request_type": {
                    "type": "string",
                    "example": "1"
                },
                "status": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "handler.createMessageProviderRequest": {
            "type": "object",
            "required": [
                "configuration_keys",
                "provider_name",
                "services",
                "short_name",
                "status"
            ],
            "properties": {
                "configuration_keys": {
                    "type": "string",
                    "example": "[{\"keyname\":\"key1\",\"keyvalue\":\"keyvalue1\"},{\"keyname\":\"key2\",\"keyvalue\":\"keyvalue2\"}]"
                },
                "provider_name": {
                    "type": "string",
                    "example": "Test Provider"
                },
                "services": {
                    "type": "string",
                    "example": "1,2,3,4"
                },
                "short_name": {
                    "type": "string",
                    "example": "TP"
                },
                "status": {
                    "description": "ConfigurationKeys interface{} ` + "`" + `json:\"configuration_keys\" validate:\"required\"` + "`" + `",
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "handler.createSMSRequest": {
            "type": "object",
            "required": [
                "application_id",
                "facility_id",
                "message_text",
                "mobile_numbers",
                "priority",
                "sender_id",
                "template_id"
            ],
            "properties": {
                "application_id": {
                    "type": "string",
                    "example": "4"
                },
                "entity_id": {
                    "type": "string",
                    "example": "1301157641566214705"
                },
                "facility_id": {
                    "type": "string",
                    "example": "facility1"
                },
                "message_text": {
                    "type": "string",
                    "example": "Your OTP is : 1342789 for Account_Creation. Please keep it for further references"
                },
                "message_type": {
                    "type": "string",
                    "example": "PM"
                },
                "mobile_numbers": {
                    "type": "string",
                    "example": "9000000000"
                },
                "priority": {
                    "type": "integer",
                    "example": 1
                },
                "reqid": {
                    "type": "integer"
                },
                "sender_id": {
                    "type": "string",
                    "example": "INPOST"
                },
                "template_id": {
                    "type": "string",
                    "example": "1307160377410448739"
                }
            }
        },
        "handler.createTemplateRequest": {
            "type": "object",
            "required": [
                "application_id",
                "gateway",
                "message_type",
                "sender_id",
                "status",
                "template_format",
                "template_id",
                "template_name"
            ],
            "properties": {
                "application_id": {
                    "type": "string",
                    "example": "4"
                },
                "entity_id": {
                    "type": "string",
                    "example": "1001051725995192803"
                },
                "gateway": {
                    "type": "string",
                    "example": "1"
                },
                "message_type": {
                    "type": "string",
                    "example": "PM"
                },
                "sender_id": {
                    "type": "string",
                    "example": "INPOST"
                },
                "status": {
                    "type": "boolean",
                    "example": true
                },
                "template_format": {
                    "type": "string",
                    "example": "Dear {#var#}, Greetings from India Post on the occasion of {#var#} - Indiapost"
                },
                "template_id": {
                    "type": "string",
                    "example": "1007188452935484904"
                },
                "template_local_id": {
                    "type": "integer"
                },
                "template_name": {
                    "type": "string",
                    "example": "Test Template"
                }
            }
        },
        "handler.createTestSMSRequest": {
            "type": "object",
            "required": [
                "mobile_number"
            ],
            "properties": {
                "mobile_number": {
                    "description": "Mobile number as request parameter",
                    "type": "string"
                }
            }
        },
        "handler.initiateBulkSMSRequest": {
            "type": "object",
            "required": [
                "application_id",
                "mobile_no",
                "template_name",
                "test_msg"
            ],
            "properties": {
                "application_id": {
                    "type": "string",
                    "example": "4"
                },
                "entity_id": {
                    "type": "string"
                },
                "file_id": {
                    "type": "integer"
                },
                "isverified": {
                    "type": "integer"
                },
                "messsage_type": {
                    "type": "string"
                },
                "mobile_no": {
                    "type": "string",
                    "example": "9000000000"
                },
                "reference_id": {
                    "type": "string"
                },
                "sender_id": {
                    "type": "string"
                },
                "template_id": {
                    "type": "string"
                },
                "template_name": {
                    "type": "string",
                    "example": "355"
                },
                "test_msg": {
                    "type": "string",
                    "example": "Your Transaction is Successful. Your Order No is 906627, booked on : 180261"
                }
            }
        },
        "handler.sendBulkSMSRequest": {
            "type": "object",
            "required": [
                "entity_id",
                "message_text",
                "message_type",
                "mobile_number",
                "sender_id",
                "template_id"
            ],
            "properties": {
                "entity_id": {
                    "type": "string"
                },
                "message_text": {
                    "type": "string"
                },
                "message_type": {
                    "type": "string"
                },
                "mobile_number": {
                    "type": "string"
                },
                "sender_id": {
                    "type": "string"
                },
                "template_id": {
                    "type": "string"
                }
            }
        },
        "handler.updateMessageApplicationRequest": {
            "type": "object",
            "required": [
                "application_name",
                "request_type",
                "status"
            ],
            "properties": {
                "application_name": {
                    "type": "string",
                    "example": "Test Application"
                },
                "request_type": {
                    "type": "string",
                    "example": "1"
                },
                "status": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "handler.updateMessageProviderRequest": {
            "type": "object",
            "required": [
                "provider_name",
                "services",
                "status"
            ],
            "properties": {
                "configuration_keys": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "provider_name": {
                    "type": "string",
                    "example": "Test Provider"
                },
                "services": {
                    "type": "string",
                    "example": "1,2,3,4"
                },
                "status": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "handler.updateTemplateRequest": {
            "type": "object",
            "required": [
                "application_id",
                "gateway",
                "message_type",
                "sender_id",
                "status",
                "template_format",
                "template_id",
                "template_name"
            ],
            "properties": {
                "application_id": {
                    "type": "string",
                    "example": "4"
                },
                "entity_id": {
                    "type": "string"
                },
                "gateway": {
                    "type": "string",
                    "example": "1"
                },
                "message_type": {
                    "type": "string",
                    "example": "PM"
                },
                "sender_id": {
                    "type": "string",
                    "example": "INPOST"
                },
                "status": {
                    "type": "boolean",
                    "example": true
                },
                "template_format": {
                    "type": "string",
                    "example": "Standing Instruction {#var#} on Account No {#var#} was cancelled."
                },
                "template_id": {
                    "type": "string",
                    "example": "1007002656392643880"
                },
                "template_name": {
                    "type": "string",
                    "example": "Std. Instruction CANCELLATION"
                }
            }
        },
        "response.AggregateSMSReportAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/response.aggregateSMSReportResponse"
                    }
                },
                "limit": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "order_by": {
                    "type": "string"
                },
                "returned_records_count": {
                    "type": "integer"
                },
                "skip": {
                    "type": "integer"
                },
                "sort_type": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                },
                "total_records_count": {
                    "type": "integer"
                }
            }
        },
        "response.BulkSMSInitiateAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "$ref": "#/definitions/response.bulkSMSInitiateResponse"
                },
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.CreateMsgApplicationAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "$ref": "#/definitions/response.createMsgApplicationResponse"
                },
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.CreateSMSAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "$ref": "#/definitions/response.createSMSResponse"
                },
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.CreateSMSProviderAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "$ref": "#/definitions/response.createSMSProviderResponse"
                },
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.CreateTemplateAPIResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.FetchMsgApplicationAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/response.fetchMsgApplicationResponse"
                    }
                },
                "limit": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "order_by": {
                    "type": "string"
                },
                "returned_records_count": {
                    "type": "integer"
                },
                "skip": {
                    "type": "integer"
                },
                "sort_type": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                },
                "total_records_count": {
                    "type": "integer"
                }
            }
        },
        "response.FetchSMSProviderAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/response.fetchSMSProviderResponse"
                    }
                },
                "limit": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "order_by": {
                    "type": "string"
                },
                "returned_records_count": {
                    "type": "integer"
                },
                "skip": {
                    "type": "integer"
                },
                "sort_type": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                },
                "total_records_count": {
                    "type": "integer"
                }
            }
        },
        "response.FetchTemplateAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "description": "MetaDataResponse     ` + "`" + `json:\",inline\"` + "`" + `",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/response.fetchTemplateResponse"
                    }
                },
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.FetchTemplateDetailsAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "description": "MetaDataResponse     ` + "`" + `json:\",inline\"` + "`" + `",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/response.fetchTemplateDetailsResponse"
                    }
                },
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.FetchTemplateNameAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "description": "MetaDataResponse     ` + "`" + `json:\",inline\"` + "`" + `",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/response.fetchTemplateNameResponse"
                    }
                },
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.ListMsgApplicationsAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/response.listMsgApplicationsResponse"
                    }
                },
                "limit": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "order_by": {
                    "type": "string"
                },
                "returned_records_count": {
                    "type": "integer"
                },
                "skip": {
                    "type": "integer"
                },
                "sort_type": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                },
                "total_records_count": {
                    "type": "integer"
                }
            }
        },
        "response.ListSMSProvidersAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/response.listSMSProvidersResponse"
                    }
                },
                "limit": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "order_by": {
                    "type": "string"
                },
                "returned_records_count": {
                    "type": "integer"
                },
                "skip": {
                    "type": "integer"
                },
                "sort_type": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                },
                "total_records_count": {
                    "type": "integer"
                }
            }
        },
        "response.ListTemplatesAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/response.listTemplatesResponse"
                    }
                },
                "limit": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "order_by": {
                    "type": "string"
                },
                "returned_records_count": {
                    "type": "integer"
                },
                "skip": {
                    "type": "integer"
                },
                "sort_type": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                },
                "total_records_count": {
                    "type": "integer"
                }
            }
        },
        "response.SMSDashboardAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "$ref": "#/definitions/response.smsDashboardResponse"
                },
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.SMSSentStatusReportAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/response.smsSentStatusReportResponse"
                    }
                },
                "limit": {
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "order_by": {
                    "type": "string"
                },
                "returned_records_count": {
                    "type": "integer"
                },
                "skip": {
                    "type": "integer"
                },
                "sort_type": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                },
                "total_records_count": {
                    "type": "integer"
                }
            }
        },
        "response.SendBulkSMSAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "$ref": "#/definitions/response.sendBulkSMSResponse"
                },
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.TestSMSAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "object",
                    "additionalProperties": true
                },
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.ToggleAppStatusAPIResponse": {
            "type": "object",
            "properties": {
                "data": {},
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.ToggleProviderStatusAPIResponse": {
            "type": "object",
            "properties": {
                "data": {},
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.ToggleTemplateStatusAPIResponse": {
            "type": "object",
            "properties": {
                "data": {},
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.UpdateMsgApplicationAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "$ref": "#/definitions/response.updateMsgApplicationResponse"
                },
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.UpdateSMSProviderAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "$ref": "#/definitions/response.updateSMSProviderResponse"
                },
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.UpdateTemplatesAPIResponse": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.ValidateBulkSMSOTPAPIResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "type": "boolean"
                },
                "message": {
                    "type": "string"
                },
                "status_code": {
                    "type": "integer"
                },
                "success": {
                    "type": "boolean"
                }
            }
        },
        "response.aggregateSMSReportResponse": {
            "type": "object",
            "properties": {
                "application_name": {
                    "type": "string"
                },
                "created_date": {
                    "type": "string"
                },
                "failed": {
                    "type": "integer"
                },
                "provider_name": {
                    "type": "string"
                },
                "serial_no": {
                    "type": "integer"
                },
                "success": {
                    "type": "integer"
                },
                "template_name": {
                    "type": "string"
                },
                "total_sms": {
                    "type": "integer"
                }
            }
        },
        "response.bulkSMSInitiateResponse": {
            "type": "object",
            "properties": {
                "msgResponse": {
                    "type": "string"
                },
                "referenceID": {
                    "type": "string"
                }
            }
        },
        "response.createMsgApplicationResponse": {
            "type": "object",
            "properties": {
                "application_id": {
                    "type": "integer"
                },
                "application_name": {
                    "type": "string"
                },
                "created_date": {
                    "type": "string"
                },
                "request_type": {
                    "type": "string"
                },
                "secret_key": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                },
                "updated_date": {
                    "type": "string"
                }
            }
        },
        "response.createSMSProviderResponse": {
            "type": "object",
            "properties": {
                "configuration_keys": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "provider_id": {
                    "type": "integer"
                },
                "provider_name": {
                    "type": "string"
                },
                "services": {
                    "type": "string"
                },
                "short_name": {
                    "type": "string"
                },
                "status": {
                    "description": "ConfigurationKeys interface{} ` + "`" + `json:\"configuration_keys\" db:\"configuration_key\"` + "`" + `",
                    "type": "integer"
                }
            }
        },
        "response.createSMSResponse": {
            "type": "object",
            "properties": {
                "communication_id": {
                    "type": "string"
                },
                "complete_response": {
                    "type": "string"
                },
                "referenceID": {
                    "type": "string"
                },
                "response_text": {
                    "type": "string"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "response.fetchMsgApplicationResponse": {
            "type": "object",
            "properties": {
                "application_id": {
                    "type": "integer"
                },
                "application_name": {
                    "type": "string"
                },
                "request_type": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "response.fetchSMSProviderResponse": {
            "type": "object",
            "properties": {
                "configuration_keys": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "provider_id": {
                    "type": "integer"
                },
                "provider_name": {
                    "type": "string"
                },
                "services": {
                    "type": "string"
                },
                "short_name": {
                    "type": "string"
                },
                "status": {
                    "description": "ConfigurationKeys interface{} ` + "`" + `json:\"configuration_keys\" db:\"configuration_key\"` + "`" + `",
                    "type": "integer"
                }
            }
        },
        "response.fetchTemplateDetailsResponse": {
            "type": "object",
            "properties": {
                "entity_id": {
                    "type": "string"
                },
                "message_type": {
                    "type": "string"
                },
                "sender_id": {
                    "type": "string"
                },
                "template_format": {
                    "type": "string"
                },
                "template_id": {
                    "type": "string"
                },
                "template_local_id": {
                    "type": "integer"
                },
                "template_name": {
                    "type": "string"
                }
            }
        },
        "response.fetchTemplateNameResponse": {
            "type": "object",
            "properties": {
                "template_local_id": {
                    "type": "integer"
                },
                "template_name": {
                    "type": "string"
                }
            }
        },
        "response.fetchTemplateResponse": {
            "type": "object",
            "properties": {
                "application_id": {
                    "type": "string"
                },
                "entity_id": {
                    "type": "string"
                },
                "gateway": {
                    "type": "string"
                },
                "message_type": {
                    "type": "string"
                },
                "sender_id": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                },
                "template_format": {
                    "type": "string"
                },
                "template_id": {
                    "type": "string"
                },
                "template_local_id": {
                    "type": "integer"
                },
                "template_name": {
                    "type": "string"
                },
                "totalCount": {
                    "type": "integer"
                }
            }
        },
        "response.listMsgApplicationsResponse": {
            "type": "object",
            "properties": {
                "application_id": {
                    "type": "integer"
                },
                "application_name": {
                    "type": "string"
                },
                "request_type": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                }
            }
        },
        "response.listSMSProvidersResponse": {
            "type": "object",
            "properties": {
                "configuration_keys": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "provider_id": {
                    "type": "integer"
                },
                "provider_name": {
                    "type": "string"
                },
                "services": {
                    "type": "string"
                },
                "short_name": {
                    "type": "string"
                },
                "status": {
                    "description": "ConfigurationKeys interface{} ` + "`" + `json:\"configuration_keys\" db:\"configuration_key\"` + "`" + `",
                    "type": "integer"
                }
            }
        },
        "response.listTemplatesResponse": {
            "type": "object",
            "properties": {
                "application_id": {
                    "type": "string"
                },
                "entity_id": {
                    "type": "string"
                },
                "gateway": {
                    "type": "string"
                },
                "message_type": {
                    "type": "string"
                },
                "sender_id": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                },
                "template_format": {
                    "type": "string"
                },
                "template_id": {
                    "type": "string"
                },
                "template_local_id": {
                    "type": "integer"
                },
                "template_name": {
                    "type": "string"
                }
            }
        },
        "response.sendBulkSMSResponse": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string"
                },
                "info": {
                    "type": "string"
                },
                "request_id": {
                    "type": "string"
                },
                "timestamp": {
                    "type": "string"
                }
            }
        },
        "response.smsDashboardResponse": {
            "type": "object",
            "properties": {
                "total_applications": {
                    "type": "integer"
                },
                "total_bulk_messages": {
                    "type": "integer"
                },
                "total_otp_messages": {
                    "type": "integer"
                },
                "total_prom_messages": {
                    "type": "integer"
                },
                "total_providers": {
                    "type": "integer"
                },
                "total_sms_sent": {
                    "type": "integer"
                },
                "total_templates": {
                    "type": "integer"
                },
                "total_trans_messages": {
                    "type": "integer"
                }
            }
        },
        "response.smsSentStatusReportResponse": {
            "type": "object",
            "properties": {
                "application_id": {
                    "type": "string"
                },
                "comm_id": {
                    "type": "string"
                },
                "created_date": {
                    "type": "string"
                },
                "facility_id": {
                    "type": "string"
                },
                "gateway_id": {
                    "type": "string"
                },
                "message_priority": {
                    "type": "integer"
                },
                "message_text": {
                    "type": "string"
                },
                "mobile_number": {
                    "type": "integer"
                },
                "serial_no": {
                    "type": "integer"
                },
                "status": {
                    "type": "string"
                }
            }
        },
        "response.updateMsgApplicationResponse": {
            "type": "object",
            "properties": {
                "application_id": {
                    "type": "integer"
                },
                "application_name": {
                    "type": "string"
                },
                "request_type": {
                    "type": "string"
                },
                "status": {
                    "type": "integer"
                },
                "updated_date": {
                    "type": "string"
                }
            }
        },
        "response.updateSMSProviderResponse": {
            "type": "object",
            "properties": {
                "configuration_keys": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                },
                "provider_id": {
                    "type": "integer"
                },
                "provider_name": {
                    "type": "string"
                },
                "services": {
                    "type": "string"
                },
                "short_name": {
                    "type": "string"
                },
                "status": {
                    "description": "ConfigurationKeys interface{} ` + "`" + `json:\"configuration_keys\" db:\"configuration_key\"` + "`" + `",
                    "type": "integer"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/v1",
        Schemes:          []string{"http", "https"},
        Title:            "Message Gateway API",
        Description:      "A comprehensive API for managing addresses, offering endpoints for creation, update, deletion, and retrieval of Message Gateway data",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package handler

import (
        "MgApplication/core/domain"
        "MgApplication/core/port"
        "MgApplication/handler/response"
        repo "MgApplication/repo/postgres"
        "math"

        "github.com/gin-gonic/gin"
        config "MgApplication/api-config"
        apierrors "MgApplication/api-errors"
        log "MgApplication/api-log"
        validation "MgApplication/api-validation"
)

// MgApplication Handler represents the HTTP handler for MgApplication related requests
type ApplicationHandler struct {
        svc *repo.ApplicationRepository
        c   *config.Config
}

// MgApplication Handler creates a new MgApplicatPion Handler instance
func NewApplicationHandler(svc *repo.ApplicationRepository, c *config.Config) *ApplicationHandler <span class="cov8" title="1">{
        return &amp;ApplicationHandler{
                svc,
                c,
        }
}</span>

// create MgApplication  Request represents a request body for creating a MgApplication Handler
type createMessageApplicationRequest struct {
        ApplicationID   uint64 `json:"application_id"`
        ApplicationName string `json:"application_name" validate:"required" example:"Test Application"`
        RequestType     string `json:"request_type" validate:"required,request_type" example:"1"`
        Status          bool   `json:"status" validate:"required" example:"true"`
}

// CreateMsgApplication godoc
//
//        @Summary                Creates a message application
//        @Description        Creates a new message application
//        @Tags                        Applications
//        @ID                                CreateMessageApplicationHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        createMessageApplicationRequest        body                createMessageApplicationRequest                                true        "Creates Message Application"
//        @Success                201                                                                {object}        response.CreateMsgApplicationAPIResponse        "New Message Application is created"
//        @Failure                400                                                                {object}        apierrors.APIErrorResponse                                        "Bad Request"
//        @Failure                401                                                                {object}        apierrors.APIErrorResponse                                        "Unauthorized"
//        @Failure                403                                                                {object}        apierrors.APIErrorResponse                                        "Forbidden"
//        @Failure                404                                                                {object}        apierrors.APIErrorResponse                                        "Data not found"
//        @Failure                409                                                                {object}        apierrors.APIErrorResponse                                        "Data conflict errpr"
//        @Failure                422                                                                {object}        apierrors.APIErrorResponse                                        "Binding or Validation error"
//        @Failure                500                                                                {object}        apierrors.APIErrorResponse                                        "Internal server error"
//        @Failure                502                                                                {object}        apierrors.APIErrorResponse                                        "Bad Gateway"
//        @Failure                504                                                                {object}        apierrors.APIErrorResponse                                        "Gateway Timeout"
//        @Router                        /applications [post]
func (ah *ApplicationHandler) CreateMessageApplicationHandler(ctx *gin.Context) <span class="cov8" title="1">{
        var req createMessageApplicationRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for createMessageApplicationRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for createMessageApplicationRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">SecretKeyGenerated, errSecret := GenerateRandomString(16)
        if errSecret != nil </span><span class="cov0" title="0">{
                apierrors.HandleError(ctx, errSecret)
                log.Error(ctx, "Error while generating secret key: %s", errSecret.Error())
                return
        }</span>

        <span class="cov8" title="1">var aStatus int
        if req.Status </span><span class="cov8" title="1">{
                aStatus = 1
        }</span> else<span class="cov0" title="0"> {
                aStatus = 0
        }</span>

        <span class="cov8" title="1">msgappreq := domain.MsgApplications{
                ApplicationName: req.ApplicationName,
                RequestType:     req.RequestType,
                SecretKey:       SecretKeyGenerated,
                Status:          aStatus,
        }

        msg, err := ah.svc.CreateMsgApplicationRepo(ctx, &amp;msgappreq)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in CreateMsgApplicationRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">rsp := response.NewCreateMsgApplicationResponse(&amp;msg)
        apiRsp := response.CreateMsgApplicationAPIResponse{
                StatusCodeAndMessage: port.CreateSuccess,
                Data:                 rsp,
        }

        log.Debug(ctx, "CreateMessageApplicationHandler response: %v", apiRsp)
        handleCreateSuccess(ctx, apiRsp)</span>
}

type updateMessageApplicationRequest struct {
        ApplicationID   uint64 `uri:"application-id" validate:"required,numeric" example:"4" json:"-"`
        ApplicationName string `json:"application_name" validate:"required" example:"Test Application"`
        RequestType     string `json:"request_type" validate:"required,request_type" example:"1"`
        Status          bool   `json:"status" validate:"required" example:"true"`
}

// UpdateMessageApplication godoc
//
//        @Summary                Edits an existing Message Application
//        @Description        Allows editing of an existing Message Application
//        @Tags                        Applications
//        @ID                                UpdateMessageApplicationHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        application-id                                        path                uint64                                                                                true        "Edit Message Application Request"        SchemaExample(4)
//        @Param                        updateMessageApplicationRequest        body                updateMessageApplicationRequest                                true        "Edit Message Application Request"
//        @Success                200                                                                {object}        response.UpdateMsgApplicationAPIResponse        "Message Application is modified"
//        @Failure                400                                                                {object}        apierrors.APIErrorResponse                                        "Bad Request"
//        @Failure                401                                                                {object}        apierrors.APIErrorResponse                                        "Unauthorized"
//        @Failure                403                                                                {object}        apierrors.APIErrorResponse                                        "Forbidden"
//        @Failure                404                                                                {object}        apierrors.APIErrorResponse                                        "Data not found"
//        @Failure                409                                                                {object}        apierrors.APIErrorResponse                                        "Data conflict errpr"
//        @Failure                422                                                                {object}        apierrors.APIErrorResponse                                        "Binding or Validation error"
//        @Failure                500                                                                {object}        apierrors.APIErrorResponse                                        "Internal server error"
//        @Failure                502                                                                {object}        apierrors.APIErrorResponse                                        "Bad Gateway"
//        @Failure                504                                                                {object}        apierrors.APIErrorResponse                                        "Gateway Timeout"
//        @Router                        /applications/{application-id} [put]
func (ah *ApplicationHandler) UpdateMessageApplicationHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req updateMessageApplicationRequest
        if err := ctx.ShouldBindUri(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "URI Binding failed for updateMessageApplicationRequest: %s", err.Error())
                return
        }</span>
        <span class="cov8" title="1">if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "JSON Binding failed for updateMessageApplicationRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for updateMessageApplicationRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">var aStatus int
        if req.Status </span><span class="cov8" title="1">{
                aStatus = 1
        }</span> else<span class="cov0" title="0"> {
                aStatus = 0
        }</span>

        <span class="cov8" title="1">msgappreq := domain.EditApplication{
                ApplicationID:   req.ApplicationID,
                ApplicationName: req.ApplicationName,
                RequestType:     req.RequestType,
                Status:          aStatus,
        }

        msgApp, err := ah.svc.UpdateMsgApplicationRepo(ctx, &amp;msgappreq)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in EditMsgApplicationRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">rsp := response.NewUpdateMsgApplicationResponse(&amp;msgApp)
        apiRsp := response.UpdateMsgApplicationAPIResponse{
                StatusCodeAndMessage: port.UpdateSuccess,
                Data:                 rsp,
        }

        log.Debug(ctx, "UpdateMessageApplicationHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}

type listMessageApplicationsRequest struct {
        Status bool `form:"status"  example:"true" validate:"omitempty"`
        port.MetaDataRequest
}

// ListMessageApplicationsHandler godoc
//
//        @Summary                Get Message Applications
//        @Description        Lists all message applications
//        @Tags                        Applications
//        @ID                                ListMessageApplicationsHandler
//        @Produce                json
//        @Param                        listMessageApplicationsRequest        query                listMessageApplicationsRequest                        false        "Get Applications (by query)"
//        @Success                200                                                                {object}        response.ListMsgApplicationsAPIResponse        "All Message Applications are retrieved"
//        @Failure                400                                                                {object}        apierrors.APIErrorResponse                                "Bad Request"
//        @Failure                401                                                                {object}        apierrors.APIErrorResponse                                "Unauthorized"
//        @Failure                403                                                                {object}        apierrors.APIErrorResponse                                "Forbidden"
//        @Failure                404                                                                {object}        apierrors.APIErrorResponse                                "Data not found"
//        @Failure                409                                                                {object}        apierrors.APIErrorResponse                                "Data conflict errpr"
//        @Failure                422                                                                {object}        apierrors.APIErrorResponse                                "Binding or Validation error"
//        @Failure                500                                                                {object}        apierrors.APIErrorResponse                                "Internal server error"
//        @Failure                502                                                                {object}        apierrors.APIErrorResponse                                "Bad Gateway"
//        @Failure                504                                                                {object}        apierrors.APIErrorResponse                                "Gateway Timeout"
//        @Router                        /applications [get]
func (ah *ApplicationHandler) ListMessageApplicationsHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req listMessageApplicationsRequest

        if err := ctx.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for listMessageApplicationsRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for listMessageApplicationsRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if req.Limit == 0 &amp;&amp; req.Skip == 0 </span><span class="cov0" title="0">{
                req.Limit = math.MaxInt32
        }</span>

        <span class="cov8" title="1">msgappreq := domain.ListApplications{
                Status: req.Status,
        }

        applications, err := ah.svc.ListApplicationsRepo(ctx, msgappreq, req.MetaDataRequest)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in ListApplicationsRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">total := len(applications)
        rsp := response.NewListMsgApplicationsResponse(applications)
        metadata := port.NewMetaDataResponse(req.Skip, req.Limit, total)

        apiRsp := response.ListMsgApplicationsAPIResponse{
                StatusCodeAndMessage: port.ListSuccess,
                MetaDataResponse:     metadata,
                Data:                 rsp,
        }

        log.Debug(ctx, "ListMessageApplicationsHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}

type fetchApplicationRequest struct {
        ApplicationID uint64 `uri:"application-id" validate:"required,numeric"  example:"4"`
}

// FetchApplicationHandler godoc
//
//        @Summary                Get Message Application by ApplicationID
//        @Description        Fetches Message Application by ApplicationID
//        @Tags                        Applications
//        @ID                                FetchApplicationHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        fetchApplicationRequest        path                fetchApplicationRequest                                        true        "Get Application Request (example:1)"
//        @Success                200                                                {object}        response.FetchMsgApplicationAPIResponse        "Message Application is retrieved"
//        @Failure                400                                                {object}        apierrors.APIErrorResponse                                "Bad Request"
//        @Failure                401                                                {object}        apierrors.APIErrorResponse                                "Unauthorized"
//        @Failure                403                                                {object}        apierrors.APIErrorResponse                                "Forbidden"
//        @Failure                404                                                {object}        apierrors.APIErrorResponse                                "Data not found"
//        @Failure                409                                                {object}        apierrors.APIErrorResponse                                "Data conflict errpr"
//        @Failure                422                                                {object}        apierrors.APIErrorResponse                                "Binding or Validation error"
//        @Failure                500                                                {object}        apierrors.APIErrorResponse                                "Internal server error"
//        @Failure                502                                                {object}        apierrors.APIErrorResponse                                "Bad Gateway"
//        @Failure                504                                                {object}        apierrors.APIErrorResponse                                "Gateway Timeout"
//        @Router                        /applications/{application-id} [get]
func (ah *ApplicationHandler) FetchApplicationHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req fetchApplicationRequest
        if err := ctx.ShouldBindUri(&amp;req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for fetchApplicationRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for fetchApplicationRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">msgappreq := domain.MsgApplications{
                ApplicationID: req.ApplicationID,
        }

        applications, err := ah.svc.FetchApplicationRepo(ctx, &amp;msgappreq)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in GetAppbyIDRepo function: %s", err.Error())
                return
        }</span>

        // total := len(applications)
        <span class="cov8" title="1">rsp := response.NewFetchMsgApplicationResponse(applications)
        // metadata := response.NewMetaDataResponse(0, 0, total)

        apiRsp := response.FetchMsgApplicationAPIResponse{
                StatusCodeAndMessage: port.FetchSuccess,
                // MetaDataResponse:     metadata,
                Data: rsp,
        }

        log.Debug(ctx, "FetchApplicationHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>

}

type toggleApplicationStatusRequest struct {
        ApplicationID uint64 `uri:"application-id" validate:"required,numeric" example:"4"`
}

// ToggleApplicationStatus godoc
//
//        @Summary                Modifies the status of Message Application
//        @Description        Toggles the status of Message Application
//        @Tags                        Applications
//        @ID                                ToggleApplicationStatusHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        toggleApplicationStatusRequest        path                toggleApplicationStatusRequest                true        "Application ID (example:5)"
//        @Success                200                                                                {object}        response.ToggleAppStatusAPIResponse        "Message Application status is modified"
//        @Failure                400                                                                {object}        apierrors.APIErrorResponse                        "Bad Request"
//        @Failure                401                                                                {object}        apierrors.APIErrorResponse                        "Unauthorized"
//        @Failure                403                                                                {object}        apierrors.APIErrorResponse                        "Forbidden"
//        @Failure                404                                                                {object}        apierrors.APIErrorResponse                        "Data not found"
//        @Failure                409                                                                {object}        apierrors.APIErrorResponse                        "Data conflict errpr"
//        @Failure                422                                                                {object}        apierrors.APIErrorResponse                        "Binding or Validation error"
//        @Failure                500                                                                {object}        apierrors.APIErrorResponse                        "Internal server error"
//        @Failure                502                                                                {object}        apierrors.APIErrorResponse                        "Bad Gateway"
//        @Failure                504                                                                {object}        apierrors.APIErrorResponse                        "Gateway Timeout"
//        @Router                        /applications/{application-id}/status [put]
func (ah *ApplicationHandler) ToggleApplicationStatusHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req toggleApplicationStatusRequest

        if err := ctx.ShouldBindUri(&amp;req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for toggleApplicationStatusRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for toggleApplicationStatusRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">msgappreq := domain.StatusApplication{
                ApplicationID: req.ApplicationID,
        }

        applications, err := ah.svc.ToggleApplicationStatusRepo(ctx, &amp;msgappreq)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in StatusMsgApplicationRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">apiRsp := response.ToggleAppStatusAPIResponse{
                StatusCodeAndMessage: port.UpdateSuccess,
                //MetaDataResponse:     metadata,
                Data: applications,
        }

        log.Debug(ctx, "ToggleApplicationStatusHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package handler

import (
        "MgApplication/core/domain"
        "MgApplication/core/port"
        "MgApplication/handler/response"
        "bytes"
        "encoding/xml"
        "fmt"
        "io"
        "net/http"
        "strings"
        "sync"
        "time"

        "github.com/gin-gonic/gin"

        apierrors "MgApplication/api-errors"
        log "MgApplication/api-log"
        validation "MgApplication/api-validation"
)

type initiateBulkSMSRequest struct {
        File          uint64 `json:"file_id"`
        ReferenceID   string `json:"reference_id"`
        ApplicationID string `json:"application_id" validate:"required" example:"4"`
        TemplateName  string `json:"template_name" validate:"required" example:"355"`
        TemplateID    string `json:"template_id"`
        EntityID      string `json:"entity_id"`
        SenderID      string `json:"sender_id"`
        MobileNo      string `json:"mobile_no" validate:"required" example:"9000000000"`
        TestMessage   string `json:"test_msg" validate:"required" example:"Your Transaction is Successful. Your Order No is 906627, booked on : 180261"`
        MessageType   string `json:"messsage_type"`
        IsVerified    int    `json:"isverified"`
}

// InitiateBulkSMS godoc
//
//        @Summary                Send Bulk SMSes
//        @Description        Initiates sending of Bulk SMSes
//        @Tags                        BulkSMS
//        @ID                                InitiateBulkSMSHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        initiateBulkSMSRequest        body                initiateBulkSMSRequest                                true        "Initiate Bulk SMS Request"
//        @Success                201                                                {object}        response.BulkSMSInitiateAPIResponse        "Submitted successfully"
//        @Failure                400                                                {object}        apierrors.APIErrorResponse                        "Bad Request"
//        @Failure                401                                                {object}        apierrors.APIErrorResponse                        "Unauthorized"
//        @Failure                403                                                {object}        apierrors.APIErrorResponse                        "Forbidden"
//        @Failure                404                                                {object}        apierrors.APIErrorResponse                        "Data not found"
//        @Failure                409                                                {object}        apierrors.APIErrorResponse                        "Data conflict errpr"
//        @Failure                422                                                {object}        apierrors.APIErrorResponse                        "Binding or Validation error"
//        @Failure                500                                                {object}        apierrors.APIErrorResponse                        "Internal server error"
//        @Failure                502                                                {object}        apierrors.APIErrorResponse                        "Bad Gateway"
//        @Failure                504                                                {object}        apierrors.APIErrorResponse                        "Gateway Timeout"
//        @Router                        /bulk-sms-initiate [post]
func (ch *MgApplicationHandler) InitiateBulkSMSHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req initiateBulkSMSRequest

        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleError(ctx, err)
                log.Error(ctx, "Binding failed for initiateBulkSMSRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for initiateBulkSMSRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">initiateSMS := domain.InitiateBulkSMS{
                ApplicationID: req.ApplicationID,
                TemplateName:  req.TemplateName,
                MobileNo:      req.MobileNo,
                TestMessage:   req.TestMessage,
                EntityID:      req.EntityID,
                MessageType:   req.MessageType,
        }
        config, err := ch.svc.InitiateBulkSMSRepo(ctx, &amp;initiateSMS)
        if err != nil </span><span class="cov8" title="1">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in InitiateBulkSMSRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov0" title="0">dltsender := strings.Split(config, "_")
        //var TemplateID, SenderID, EntityID, reference_id string
        if len(dltsender) == 5 </span><span class="cov0" title="0">{
                req.TemplateID = dltsender[0]
                req.SenderID = dltsender[1]
                req.EntityID = dltsender[2]
                req.MessageType = dltsender[3]
                req.ReferenceID = dltsender[4]
        }</span> else<span class="cov0" title="0"> {
                req.TemplateID = ""
                req.SenderID = ""
                req.EntityID = ""
                req.MessageType = ""
                req.ReferenceID = ""
                apierrors.HandleWithMessage(ctx, "cannot initiate bulk sms")
                return
        }</span>

        <span class="cov0" title="0">if req.MessageType == "UC" </span><span class="cov0" title="0">{
                req.TestMessage = UnicodemsgConvertCDAC(req.TestMessage)
        }</span> else<span class="cov0" title="0"> {
                req.MessageType = "PM"
        }</span>

        <span class="cov0" title="0">if req.TemplateID != "" &amp;&amp; req.SenderID != "" </span><span class="cov0" title="0">{
                // Bulkrsp, err := SendSMSCDAC(ch.c.CDACUserName(), ch.c.GetString("sms.cdac.password"), req.TestMessage, req.SenderID, req.MobileNo, ch.c.GetString("sms.cdac.securekey"), req.TemplateID, req.MessageType)
                Bulkrsp, err := SendSMSCDAC(ch.c.GetString("sms.cdac.username"), ch.c.GetString("sms.cdac.password"), req.TestMessage, req.SenderID, req.MobileNo, ch.c.GetString("sms.cdac.securekey"), req.TemplateID, req.MessageType)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error sending SMS using SendSMSCDAC: %s", err.Error())
                        // ch.vs.handleError(ctx, err)
                        apierrors.HandleError(ctx, err)
                        return
                }</span>
                // response := map[string]interface{}{
                //         "msgresponse":  rsp,
                //         "reference_id": req.ReferenceID,
                // }

                <span class="cov0" title="0">rsp := response.NewBulkSMSInitiateResponse(Bulkrsp, req.ReferenceID)
                apiRsp := response.BulkSMSInitiateAPIResponse{
                        StatusCodeAndMessage: port.CreateSuccess,
                        Data:                 rsp,
                }

                handleCreateSuccess(ctx, apiRsp)</span>
        } else<span class="cov0" title="0"> {
                // ch.vs.handleError(ctx, errors.New("could not initiate bulk sms"))
                // apperror :=apierrors.AppError("could not initiate bulk sms", apierrors.HTTPErrorBadRequest.StatusCode, "")
                apierrors.HandleWithMessage(ctx, "could not initiate bulk sms")
        }</span>
}

type validateTestSMSRequest struct {
        ReferenceID string `form:"reference-id" validate:"required" example:"lnv579ejt2vmaq03i7up"`
        TestString  string `form:"test-string" validate:"required" example:"906627"`
}

// ValidateTestSMS godoc
//
//        @Summary                Validates Test SMS
//        @Description        Validates Test SMS
//        @Tags                        BulkSMS
//        @ID                                ValidateTestSMSHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        validateTestSMSRequest        query                validateTestSMSRequest                                        true        "Validate Test SMS"
//        @Success                200                                                {object}        response.ValidateBulkSMSOTPAPIResponse        "True if validation succeeds, false otherwise"
//        @Failure                400                                                {object}        apierrors.APIErrorResponse                                "Bad Request"
//        @Failure                401                                                {object}        apierrors.APIErrorResponse                                "Unauthorized"
//        @Failure                403                                                {object}        apierrors.APIErrorResponse                                "Forbidden"
//        @Failure                404                                                {object}        apierrors.APIErrorResponse                                "Data not found"
//        @Failure                409                                                {object}        apierrors.APIErrorResponse                                "Data conflict errpr"
//        @Failure                422                                                {object}        apierrors.APIErrorResponse                                "Binding or Validation error"
//        @Failure                500                                                {object}        apierrors.APIErrorResponse                                "Internal server error"
//        @Failure                502                                                {object}        apierrors.APIErrorResponse                                "Bad Gateway"
//        @Failure                504                                                {object}        apierrors.APIErrorResponse                                "Gateway Timeout"
//        @Router                        /bulk-sms-validate-otp [get]
func (ch *MgApplicationHandler) ValidateTestSMSHandler(ctx *gin.Context) <span class="cov8" title="1">{
        var req validateTestSMSRequest
        if err := ctx.ShouldBind(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "URI Binding Error in ValidateTestSMS: %s", err.Error())
                // ch.vs.handleError(ctx, err)
                apierrors.HandleError(ctx, err)
                return
        }</span>
        // if !ch.vs.handleValidation(ctx, req) {
        //         return
        // }

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for validateTestSMSRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">verifySMS := domain.ValidateTestSMS{
                ReferenceID: req.ReferenceID,
                TestString:  req.TestString,
        }
        isvalid, err := ch.svc.ValidateTestSMSRepo(ctx, &amp;verifySMS)
        if err != nil </span><span class="cov8" title="1">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in ValidateTestSMSRepo function: %s", err.Error())
                return
        }</span>
        //handleSuccess(ctx, isvalid)

        <span class="cov0" title="0">apiRsp := response.ValidateBulkSMSOTPAPIResponse{
                StatusCodeAndMessage: port.UpdateSuccess,
                Data:                 isvalid,
        }

        log.Debug(ctx, "ValidateTestSMSHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}

type FileInfo struct {
        Path         string
        CreationTime time.Time
}

var fileStore = make(map[string]FileInfo)
var mu sync.RWMutex // Use a read-write mutex

// Structs to represent the XML structure
type Request struct {
        XMLName xml.Name      `xml:"a2wml"`
        Version string        `xml:"version,attr"`
        Request RequestDetail `xml:"request"`
}

type RequestDetail struct {
        Username    string        `xml:"username,attr"`
        Pin         string        `xml:"pin,attr"`
        MessageList []MessageList `xml:"messageList"`
}

// type MessageList struct {
//         FromAddress   string `xml:"fromAddress"`
//         DestAddress   string `xml:"destAddress"`
//         MessageType          string `xml:"messageType"`
//         MessageTxt    string `xml:"messageTxt"`
//         DltTemplateID string `xml:"dlt_template_id"`
//         DltEntityID   string `xml:"dlt_entity_id"`
// }

type MessageList struct {
        FromAddress   string `xml:"fromAddress" json:"from_address"`
        DestAddress   string `xml:"destAddress" json:"dest_address"`
        MessageType   string `xml:"messageType" json:"message_type"`
        MessageTxt    string `xml:"messageTxt" json:"message_txt"`
        DltTemplateID string `xml:"dlt_template_id" json:"dlt_template_id"`
        DltEntityID   string `xml:"dlt_entity_id" json:"dlt_entity_id"`
}

type NICResponse struct {
        XMLName   xml.Name `xml:"a2wml"`
        Version   string   `xml:"response&gt;version"`
        Timestamp string   `xml:"response&gt;timestamp"`
        RequestID string   `xml:"response&gt;request ID"`
        Code      string   `xml:"response&gt;code"`
        Info      string   `xml:"response&gt;info"`
}

type SendBulkSMSRequestOld struct {
        UniqueID    string `json:"unique_id" validate:"required"` // Unique ID to retrieve the file path
        SenderID    string `json:"sender_id" validate:"required" `
        TemplateID  string `json:"template_id" validate:"required" `
        MessageType string `json:"message_type" validate:"required" `
}

type sendBulkSMSRequest struct {
        SenderID     string `json:"sender_id" validate:"required"`
        MobileNumber string `json:"mobile_number" validate:"required"`
        MessageType  string `json:"message_type" validate:"required"`
        MessageText  string `json:"message_text" validate:"required"`
        TemplateID   string `json:"template_id" validate:"required"`
        EntityID     string `json:"entity_id" validate:"required"`
}

/*
func (ch *MgApplicationHandler) SendBulkSMSOld(gctx *gin.Context) {
        var req SendBulkSMSRequestOld
        if err := gctx.BindJSON(&amp;req); err != nil {
                // c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request"})
                apierrors.HandleBindingError(gctx, err)
                return
        }

        // Retrieve the file path from fileStore using the unique ID
        mu.RLock()
        fileInfo, exists := fileStore[req.UniqueID]
        mu.RUnlock()
        if !exists {
                gctx.JSON(http.StatusNotFound, gin.H{"error": "File not found"})
                return
        }

        tempFilePath := fileInfo.Path

        // Ensure the file will be cleaned up even if an error occurs
        defer func() {
                mu.Lock()
                if err := os.Remove(tempFilePath); err != nil {
                        log.Error(gctx, "Failed to delete output Excel file: %v", err.Error())
                }
                delete(fileStore, req.UniqueID) // Remove the entry from fileStore
                mu.Unlock()
        }()

        // Read the processed output Excel file
        outputRows, err := ReadExcelFile(tempFilePath)
        if err != nil {
                gctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to read output Excel file"})
                return
        }

        var NICUsername, NICPassword string
        if req.SenderID == "INPOST" {
                // NICUsername = ch.c.NICBulkUsername()
                NICUsername = ch.c.GetString("sms.nic.bulk.username")
                // NICPassword = ch.c.NICBulkPassword()
                NICPassword = ch.c.GetString("sms.nic.bulk.password")
        } else if req.SenderID == "DOPBNK" || req.SenderID == "DOPCBS" {
                // NICUsername = ch.c.NICDOPBNKUserName()
                NICUsername = ch.c.GetString("nic.DOPBNKusername")
                // NICPassword = ch.c.NICDOPBNKPassword()
                NICPassword = ch.c.GetString("nic.DOPBNKpassword")
        } else if req.SenderID == "DOPPLI" {
                // NICUsername = ch.c.NICDOPPLIUserName()
                NICUsername = ch.c.GetString("sms.nic.DOPPLIuserName")
                // NICPassword = ch.c.NICDOPPLIPassword()
                NICPassword = ch.c.GetString("sms.nic.DOPPLIpassword")
        }

        // Create the message list, skipping the first row
        var messageList []MessageList
        for i, row := range outputRows {
                if i == 0 {
                        continue // Skip the first row
                }
                if req.MessageType == "UC" {
                        row[1] = UnicodemsgConvertNIC(row[1])
                } else {
                        req.MessageType = "PM"
                }

                messageList = append(messageList, MessageList{
                        FromAddress:   req.SenderID,
                        DestAddress:   row[0], // Assuming Mobile number is in the first column
                        MessageType:   req.MessageType,
                        MessageTxt:    row[1], // Assuming Message is in the second column
                        DltTemplateID: req.TemplateID,
                        DltEntityID:   ch.c.GetString("sms.dltEntityID"),
                })
        }

        // Create the request
        nicRequest := Request{
                Version: "2.0",
                Request: RequestDetail{
                        Username:    NICUsername,
                        Pin:         NICPassword,
                        MessageList: messageList,
                },
        }

        // Convert the request to XML
        xmlData, err := xml.MarshalIndent(nicRequest, "", "    ")
        if err != nil {
                gctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to convert data to XML"})
                return
        }

        // Print the generated XML data for inspection
        fmt.Println("Generated XML:")
        fmt.Println(string(xmlData))

        // Send the XML data to the NIC URL
        // NICBulkURL := ch.c.NICBulkURL()
        NICBulkURL := ch.c.GetString("sms.nic.bulk.url")
        resp, err := http.Post(NICBulkURL, "application/xml", bytes.NewBuffer(xmlData))
        if err != nil || resp.StatusCode != http.StatusOK {
                gctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to send data to NIC"})
                return
        }
        defer resp.Body.Close()

        // Read the response body
        responseData, err := io.ReadAll(resp.Body)
        if err != nil {
                // handleError(ctx, "Failed to read response from NIC")
                apierrors.HandleWithMessage(gctx, "Failed to read response from NIC")
                return
        }

        // Parse the XML response into NICResponse struct
        var nicResponse NICResponse
        if err := xml.Unmarshal(responseData, &amp;nicResponse); err != nil {
                handleError(gctx, "Failed to parse NIC response")
                return
        }

        // Construct the JSON response
        responseJSON := &amp;domain.NicResponse{
                Timestamp: nicResponse.Timestamp,
                RequestID: nicResponse.RequestID,
                Code:      nicResponse.Code,
                Info:      nicResponse.Info,
        }

        // handleSuccess(c, responseJSON)

        rsp := response.NewSendBulkSMSResponseOld(responseJSON)
        apiRsp := response.SendBulkSMSAPIResponse{
                StatusCodeAndMessage: port.CreateSuccess,
                Data:                 rsp,
        }

        handleSuccess(gctx, apiRsp)
}
*/

// SendBulkSMS godoc.
//
//        @Summary                Send processed Excel file data
//        @Description        This API reads the output Excel file, constructs messages, and sends them to the NIC service in XML format.
//        @Tags                        BulkSMS
//        @ID                                SendBulkSMSHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        sendBulkSMSRequest        body                []sendBulkSMSRequest                        true        "Request Body"
//        @Success                200                                        {object}        response.SendBulkSMSAPIResponse        "Successful operation"
//        @Failure                400                                        {object}        apierrors.APIErrorResponse                "Bad Request"
//        @Failure                401                                        {object}        apierrors.APIErrorResponse                "Unauthorized"
//        @Failure                403                                        {object}        apierrors.APIErrorResponse                "Forbidden"
//        @Failure                404                                        {object}        apierrors.APIErrorResponse                "Data not found"
//        @Failure                409                                        {object}        apierrors.APIErrorResponse                "Data conflict errpr"
//        @Failure                422                                        {object}        apierrors.APIErrorResponse                "Binding or Validation error"
//        @Failure                500                                        {object}        apierrors.APIErrorResponse                "Internal server error"
//        @Failure                502                                        {object}        apierrors.APIErrorResponse                "Bad Gateway"
//        @Failure                504                                        {object}        apierrors.APIErrorResponse                "Gateway Timeout"
//        @Router                        /bulk-sms [post]
func (ch *MgApplicationHandler) SendBulkSMSHandler(gctx *gin.Context) <span class="cov8" title="1">{
        var req []sendBulkSMSRequest
        if err := gctx.BindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                log.Error(gctx, "Binding failed for sendBulkSMSRequest: %s", err.Error())
                apierrors.HandleBindingError(gctx, err)
                return
        }</span>

        // if !ch.vs.handleValidation(ctx, req) {
        //         fmt.Println("Validation failed for the request.") // Debugging log
        //         return
        // }
        <span class="cov8" title="1">for _, sms := range req </span><span class="cov8" title="1">{
                if err := validation.ValidateStruct(sms); err != nil </span><span class="cov0" title="0">{
                        // fmt.Printf("sms request is %v", sms)
                        apierrors.HandleValidationError(gctx, err)
                        log.Error(gctx, "Validation failed for sendBulkSMSRequest: %s", err.Error())
                        return
                }</span>
        }

        // Ensure req is not empty and
        <span class="cov8" title="1">if len(req) == 0 </span><span class="cov0" title="0">{
                log.Info(gctx, "Request array is empty")
                gctx.JSON(http.StatusBadRequest, gin.H{"error": "Empty request"})
                return
        }</span>

        //Setting NIC Credentials Based on SenderID
        <span class="cov8" title="1">var NICUsername, NICPassword string
        senderID := req[0].SenderID
        fmt.Println("SenderID:", senderID)

        switch senderID </span>{
        case "INPOST":<span class="cov8" title="1">
                // NICUsername = ch.c.NICBulkUsername()
                NICUsername = ch.c.GetString("sms.nic.bulk.username")
                // NICPassword = ch.c.NICBulkPassword()
                NICPassword = ch.c.GetString("sms.nic.bulk.password")</span>
        case "DOPBNK", "DOPCBS":<span class="cov0" title="0">
                // NICUsername = ch.c.NICDOPBNKUserName()
                NICUsername = ch.c.GetString("nic.DOPBNKusername")
                // NICPassword = ch.c.NICDOPBNKPassword()
                NICPassword = ch.c.GetString("nic.DOPBNKpassword")</span>
        case "DOPPLI":<span class="cov0" title="0">
                // NICUsername = ch.c.NICDOPPLIUserName()
                NICUsername = ch.c.GetString("sms.nic.DOPPLIuserName")
                // NICPassword = ch.c.NICDOPPLIPassword()
                NICPassword = ch.c.GetString("sms.nic.DOPPLIpassword")</span>
        default:<span class="cov0" title="0">
                log.Error(gctx, "Unknown SenderID provided: %s", senderID)</span>
        }

        // Constructing Message List (Skipping First Row)
        <span class="cov8" title="1">var messageList []MessageList
        for _, row := range req </span><span class="cov8" title="1">{
                messageType := req[0].MessageType // Assuming MessageType is the same for all entries
                if messageType == "UC" </span><span class="cov0" title="0">{
                        row.MessageText = UnicodemsgConvertNIC(row.MessageText)
                }</span> else<span class="cov8" title="1"> {
                        messageType = "PM"
                }</span>

                <span class="cov8" title="1">messageList = append(messageList, MessageList{
                        FromAddress:   senderID,
                        DestAddress:   row.MobileNumber, // Assuming MobileNumber is the field for the destination
                        MessageType:   messageType,
                        MessageTxt:    row.MessageText,   // Assuming MessageText is the field for the message
                        DltTemplateID: req[0].TemplateID, // Assuming TemplateID is the same for all entries
                        // DltEntityID:   ch.c.DltEntityID(),
                        DltEntityID: ch.c.GetString("sms.dltEntityID"),
                })</span>
        }

        // Creating NIC Request and Convert to XML
        <span class="cov8" title="1">nicRequest := Request{
                Version: "2.0",
                Request: RequestDetail{
                        Username:    NICUsername,
                        Pin:         NICPassword,
                        MessageList: messageList,
                },
        }

        xmlData, err := xml.MarshalIndent(nicRequest, "", "    ")
        if err != nil </span><span class="cov0" title="0">{
                gctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to convert data to XML"})
                return
        }</span>
        <span class="cov8" title="1">fmt.Println("Generated XML:", string(xmlData))

        // Sending XML Data to NIC Bulk URL
        // NICBulkURL := ch.c.NICBulkURL()
        NICBulkURL := ch.c.GetString("sms.nic.bulk.url")
        resp, err := http.Post(NICBulkURL, "application/xml", bytes.NewBuffer(xmlData))
        if err != nil </span><span class="cov8" title="1">{
                log.Error(gctx, "HTTP Post Error: %s", err.Error())
                // ctx.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to send data to NIC"})
                apierrors.HandleWithMessage(gctx, "Failed to send data to NIC")
                return
        }</span>
        // fmt.Println("response is", resp)
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read and Parse the NIC Response
        responseData, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleWithMessage(gctx, "Failed to read response from NIC")
                return
        }</span>

        <span class="cov0" title="0">var nicResponse domain.NicResponseXml
        if err := xml.Unmarshal(responseData, &amp;nicResponse); err != nil </span><span class="cov0" title="0">{
                fmt.Println("XML Unmarshal Error:", err)
                apierrors.HandleWithMessage(gctx, "Failed to parse NIC response")
                return
        }</span>
        <span class="cov0" title="0">fmt.Println("Parsed NIC response:", nicResponse)

        // Construct and Send the Final JSON Response
        // responseJSON := domain.NicResponse{
        //         Timestamp: nicResponse.Timestamp,
        //         RequestID: nicResponse.RequestID,
        //         Code:      nicResponse.Code,
        //         Info:      nicResponse.Info,
        // }

        // // rsp := response.SendBulkResponse(responseJSON)
        // rsp1 := response.SendBulkResponse(&amp;responseJSON)
        // apiRsp1 := response.SendBulkSMSResponse{
        //         StatusCodeAndMessage: port.CreateSuccess,
        //         Data:                 rsp1,
        // }

        rsp := response.NewSendBulkSMSResponse(&amp;nicResponse)
        apiRsp := response.SendBulkSMSAPIResponse{
                StatusCodeAndMessage: port.CreateSuccess,
                Data:                 rsp,
        }

        handleCreateSuccess(gctx, apiRsp)</span>
}

// IsShuttingDown checks if the application is in the process of shutting down
// func IsShuttingDown() bool {
//         return isShuttingDown.Load().(bool)
// }
</pre>
		
		<pre class="file" id="file4" style="display: none">package handler

import (
        "MgApplication/core/domain"
        "MgApplication/core/port"
        "MgApplication/handler/response"
        repo "MgApplication/repo/postgres"
        "bytes"
        "net/http"
        "regexp"
        "strings"
        "time"

        "crypto/rand"
        "crypto/sha1"
        "crypto/sha512"
        "crypto/tls"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/url"

        // _ "time"

        "github.com/gin-gonic/gin"
        config "MgApplication/api-config"
        apierrors "MgApplication/api-errors"
        log "MgApplication/api-log"
        validation "MgApplication/api-validation"
)

// MgApplication Handler represents the HTTP handler for MgApplication related requests
type MgApplicationHandler struct {
        svc *repo.MgApplicationRepository
        c   *config.Config
}

// MgApplication Handler creates a new MgApplicatPion Handler instance
func NewMgApplicationHandler(svc *repo.MgApplicationRepository, c *config.Config) *MgApplicationHandler <span class="cov8" title="1">{
        return &amp;MgApplicationHandler{
                svc,
                c,
        }
}</span>

// HTML numeric character references
func UnicodemsgConvertCDAC(message string) string <span class="cov8" title="1">{
        var UnicodeMessage strings.Builder
        for _, char := range message </span><span class="cov8" title="1">{
                UnicodeMessage.WriteString(fmt.Sprintf("&amp;#%d;", char))
        }</span>
        <span class="cov8" title="1">return UnicodeMessage.String()</span>
}

// Hexadecimal Unicode Code Points
func UnicodemsgConvertNIC(message string) string <span class="cov8" title="1">{
        var UnicodeMessage strings.Builder
        for _, char := range message </span><span class="cov8" title="1">{
                UnicodeMessage.WriteString(fmt.Sprintf("%04X", char))
        }</span>
        <span class="cov8" title="1">return UnicodeMessage.String()</span>
}

type createSMSRequest struct {
        RequestID     uint64 `json:"reqid"`
        ApplicationID string `json:"application_id" validate:"required" example:"4"`
        FacilityID    string `json:"facility_id" validate:"required" example:"facility1"`
        Priority      int    `json:"priority" validate:"required" example:"1"`
        MessageText   string `json:"message_text" validate:"required" example:"Your OTP is : 1342789 for Account_Creation. Please keep it for further references"`
        SenderID      string `json:"sender_id" validate:"required" example:"INPOST"`
        MobileNumbers string `json:"mobile_numbers" validate:"required" example:"9000000000"`
        EntityId      string `json:"entity_id" example:"1301157641566214705"`
        TemplateID    string `json:"template_id" validate:"required" example:"1307160377410448739"`
        MessageType   string `json:"message_type" example:"PM"`
}

// CreateMessageRequest godoc
//
//        @Summary                Creates a message request
//        @Description        Creates message requests for application for registered templates
//        @Tags                        SMS Request
//        @ID                                CreateSMSRequestHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        createSMSRequest        body                createSMSRequest                                true        "Creates Message request"
//        @Success                201                                        {object}        response.CreateSMSAPIResponse        "Success"
//        @Failure                400                                        {object}        apierrors.APIErrorResponse                "Bad Request"
//        @Failure                401                                        {object}        apierrors.APIErrorResponse                "Unauthorized"
//        @Failure                403                                        {object}        apierrors.APIErrorResponse                "Forbidden"
//        @Failure                404                                        {object}        apierrors.APIErrorResponse                "Data not found"
//        @Failure                409                                        {object}        apierrors.APIErrorResponse                "Data conflict errpr"
//        @Failure                422                                        {object}        apierrors.APIErrorResponse                "Binding or Validation error"
//        @Failure                500                                        {object}        apierrors.APIErrorResponse                "Internal server error"
//        @Failure                502                                        {object}        apierrors.APIErrorResponse                "Bad Gateway"
//        @Failure                504                                        {object}        apierrors.APIErrorResponse                "Gateway Timeout"
//        @Router                        /sms-request [post]
func (ch *MgApplicationHandler) CreateSMSRequestHandler(ctx *gin.Context) <span class="cov8" title="1">{
        log.Debug(ctx, "Inside CreateSMSRequestHandler function")
        var req createSMSRequest
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Binding failed for CreateSMSRequestHandler: %s", err.Error())
                // ch.vs.handleError(ctx, err)
                apierrors.HandleBindingError(ctx, err)
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for CreateSMSRequestHandler: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">msgreq := domain.MsgRequest{
                FacilityID:    req.FacilityID,
                ApplicationID: req.ApplicationID,
                Priority:      req.Priority,
                MessageText:   req.MessageText,
                SenderID:      req.SenderID,
                MobileNumbers: req.MobileNumbers,
                EntityId:      req.EntityId,
                TemplateID:    req.TemplateID,
                MessageType:   req.MessageType,
        }

        //Fetch Entity ID from config, if not assigned
        // msgreq.EntityId = ch.c.DltEntityID()
        msgreq.EntityId = ch.c.GetString("sms.dltEntityID")
        log.Debug(ctx, "Entity ID is : %s", msgreq.EntityId)

        var gateway string
        // msgStoreRequest := ch.c.MessageStoreRequest()
        msgStoreRequest := ch.c.GetInt("sms.msgstorerequest")
        log.Debug(ctx, "Message Store Request ID is : %d", msgStoreRequest)

        if msgStoreRequest == 1 || msgreq.Priority == 3 || msgreq.Priority == 4 </span><span class="cov8" title="1">{
                //priorites are 1-OTP, 2-Transactional, 3-Promotional, 4-Bulk. If store is true or for Promotional and Bulk info will be saved.
                savedresponse, err := ch.svc.SaveMsgRequest(ctx, &amp;msgreq)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "DB Error in SaveMsgRequest: %s", err.Error())
                        // ch.vs.handledbError(ctx, err)
                        apierrors.HandleDBError(ctx, err)
                        return
                }</span>
                <span class="cov8" title="1">gateway = savedresponse.Gateway</span>
        } else<span class="cov0" title="0"> {
                savedresponse, err := ch.svc.GetGateway(ctx, &amp;msgreq)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "DB Error in GetGateway: %s", err.Error())
                        // ch.vs.handledbError(ctx, err)
                        apierrors.HandleDBError(ctx, err)
                        return
                }</span>
                <span class="cov0" title="0">gateway = savedresponse.Gateway</span>

        }
        <span class="cov8" title="1">log.Debug(ctx, "Gateway is : %s", gateway)

        //UC - Unicode message ; PM - Plaintext message
        if msgreq.MessageType == "UC" </span><span class="cov8" title="1">{
                if msgreq.Gateway == "1" </span><span class="cov8" title="1">{
                        msgreq.MessageText = UnicodemsgConvertCDAC(msgreq.MessageText)
                }</span> else<span class="cov8" title="1"> {
                        msgreq.MessageText = UnicodemsgConvertNIC(msgreq.MessageText)
                }</span>
        } else<span class="cov8" title="1"> {
                msgreq.MessageType = "PM"
        }</span>
        <span class="cov8" title="1">log.Debug(ctx, "Message Type is : %s", msgreq.MessageType)

        if msgreq.Priority == 1 || msgreq.Priority == 2 </span><span class="cov8" title="1">{
                if gateway == "1" </span><span class="cov8" title="1">{
                        // rsp, err := SendSMSCDAC(ch.c.CDACUserName(), ch.c.CDACPassword(), msgreq.MessageText, msgreq.SenderID, msgreq.MobileNumbers, ch.c.CDACSecureKey(), msgreq.TemplateID, msgreq.MessageType)
                        rsp, err := SendSMSCDAC(ch.c.GetString("sms.cdac.username"), ch.c.GetString("sms.cdac.password"), msgreq.MessageText, msgreq.SenderID, msgreq.MobileNumbers, ch.c.GetString("sms.cdac.securekey"), msgreq.TemplateID, msgreq.MessageType)
                        if err != nil </span><span class="cov0" title="0">{
                                msgresponse := domain.MsgResponse{
                                        CommunicationID:  msgreq.CommunicationID,
                                        CompleteResponse: rsp,
                                        ResponseCode:     "02",
                                        ResponseText:     err.Error(),
                                        ReferenceID:      "",
                                }
                                _, _ = ch.svc.SaveResponse(ctx, &amp;msgresponse)
                                // ch.vs.handleError(ctx, err)
                                apierrors.HandleError(ctx, err)
                                return
                        }</span>
                        <span class="cov8" title="1">log.Debug(ctx, "Response from SendSMSCDAC is : %s", rsp)

                        SMSResponse := rsp[:5]

                        if SMSResponse == "Error" </span><span class="cov0" title="0">{
                                pattern := `Error (\d+) : (.+)`
                                re := regexp.MustCompile(pattern)
                                matches := re.FindStringSubmatch(rsp)
                                if len(matches) &lt; 3 </span><span class="cov0" title="0">{
                                        //if error and format of the message is good
                                        // fmt.Println("No matches found.")
                                        //  customError := CustomError{Message: "Invalid Response"}
                                        msgStoreRequest := ch.c.GetInt("sms.msgstorerequest")
                                        if msgStoreRequest == 1 || msgreq.Priority == 3 || msgreq.Priority == 4 </span><span class="cov0" title="0">{
                                                msgresponse := domain.MsgResponse{
                                                        CommunicationID:  msgreq.CommunicationID,
                                                        CompleteResponse: rsp,
                                                        ResponseCode:     "400",
                                                        ResponseText:     "Invalid Response",
                                                        ReferenceID:      "",
                                                }
                                                _, _ = ch.svc.SaveResponse(ctx, &amp;msgresponse)
                                                // ch.vs.handleError(ctx, customError)
                                                apierrors.HandleWithMessage(ctx, "Invalid Response")
                                                return
                                        }</span>

                                } else<span class="cov0" title="0"> {
                                        //if error and format is not good
                                        errorNumber := matches[1]
                                        errorMessage := matches[2]
                                        customError := CustomError{Message: "401, " + errorMessage}
                                        msgStoreRequest := ch.c.GetInt("sms.msgstorerequest")
                                        if msgStoreRequest == 1 || msgreq.Priority == 3 || msgreq.Priority == 4 </span><span class="cov0" title="0">{
                                                msgresponse := domain.MsgResponse{
                                                        CommunicationID:  msgreq.CommunicationID,
                                                        CompleteResponse: rsp,
                                                        ResponseCode:     errorNumber,
                                                        ResponseText:     errorMessage,
                                                        ReferenceID:      "",
                                                }
                                                _, _ = ch.svc.SaveResponse(ctx, &amp;msgresponse)
                                        }</span>
                                        // ch.vs.handleError(ctx, customError)
                                        <span class="cov0" title="0">apierrors.HandleError(ctx, customError)
                                        return</span>
                                }
                        } else<span class="cov8" title="1"> {

                                pattern := `^(\d{3}),MsgID = (\d+)`
                                re := regexp.MustCompile(pattern)
                                matches := re.FindStringSubmatch(rsp)
                                if len(matches) &gt;= 3 </span><span class="cov8" title="1">{
                                        //if success and format is good
                                        responseCode := matches[1]
                                        referenceID := matches[2]
                                        msgStoreRequest := ch.c.GetInt("sms.msgstorerequest")
                                        if msgStoreRequest == 1 || msgreq.Priority == 3 || msgreq.Priority == 4 </span><span class="cov8" title="1">{
                                                msgresponse := domain.MsgResponse{
                                                        CommunicationID:  msgreq.CommunicationID,
                                                        CompleteResponse: rsp,
                                                        ResponseCode:     responseCode,
                                                        ResponseText:     "Submitted Successfully",
                                                        ReferenceID:      referenceID,
                                                }
                                                _, _ = ch.svc.SaveResponse(ctx, &amp;msgresponse)
                                                // handleSuccess(ctx, msgresponse)
                                                rsp := response.NewCreateSMSResponse(&amp;msgresponse)
                                                apiRsp := response.CreateSMSAPIResponse{
                                                        StatusCodeAndMessage: port.CreateSuccess,
                                                        Data:                 rsp,
                                                }
                                                handleCreateSuccess(ctx, apiRsp)
                                                return
                                        }</span>

                                } else<span class="cov0" title="0"> {
                                        // msgStoreRequest := ch.c.MessageStoreRequest()
                                        msgStoreRequest := ch.c.GetInt("sms.msgstorerequest")
                                        if msgStoreRequest == 1 || msgreq.Priority == 3 || msgreq.Priority == 4 </span><span class="cov0" title="0">{
                                                msgresponse := domain.MsgResponse{
                                                        CommunicationID:  msgreq.CommunicationID,
                                                        CompleteResponse: rsp,
                                                        ResponseCode:     "402",
                                                        ResponseText:     "Submitted Successfully",
                                                        ReferenceID:      "",
                                                }
                                                _, _ = ch.svc.SaveResponse(ctx, &amp;msgresponse)
                                                // handleSuccess(ctx, msgresponse)
                                                rsp := response.NewCreateSMSResponse(&amp;msgresponse)
                                                apiRsp := response.CreateSMSAPIResponse{
                                                        StatusCodeAndMessage: port.CreateSuccess,
                                                        Data:                 rsp,
                                                }
                                                handleCreateSuccess(ctx, apiRsp)
                                                return
                                        }</span>

                                }

                        }
                } else<span class="cov8" title="1"> if gateway == "2" </span><span class="cov8" title="1">{
                        var NICUsername, NICPassword string
                        if msgreq.SenderID == "INPOST" </span><span class="cov0" title="0">{
                                NICUsername = ch.c.GetString("sms.nic.INPOSTUserName")
                                NICPassword = ch.c.GetString("sms.nic.INPOSTPassword")
                        }</span> else<span class="cov8" title="1"> if (msgreq.SenderID == "DOPBNK") || (msgreq.SenderID == "DOPCBS") </span><span class="cov8" title="1">{
                                NICUsername = ch.c.GetString("sms.nic.DOPBNKUserName")
                                NICPassword = ch.c.GetString("sms.nic.DOPBNKPassword")
                        }</span> else<span class="cov0" title="0"> if msgreq.SenderID == "DOPPLI" </span><span class="cov0" title="0">{
                                NICUsername = ch.c.GetString("sms.nic.DOPPLIUserName")
                                NICPassword = ch.c.GetString("sms.nic.DOPPLIPassword")
                        }</span>

                        <span class="cov8" title="1">rsp, err := SendSMSNIC(NICUsername, NICPassword, msgreq.MessageText, msgreq.SenderID, msgreq.MobileNumbers, msgreq.EntityId, msgreq.TemplateID, msgreq.MessageType)

                        if err != nil </span><span class="cov8" title="1">{
                                msgresponse := domain.MsgResponse{
                                        CommunicationID:  msgreq.CommunicationID,
                                        CompleteResponse: rsp,
                                        ResponseCode:     "02",
                                        ResponseText:     err.Error(),
                                        ReferenceID:      "",
                                }
                                _, _ = ch.svc.SaveResponse(ctx, &amp;msgresponse)
                                // ch.vs.handleError(ctx, err)
                                apierrors.HandleError(ctx, err)
                                return
                        }</span>
                        <span class="cov0" title="0">pattern := `Request ID=(\d+)~code=([A-Z0-9]+)`
                        re := regexp.MustCompile(pattern)
                        matches := re.FindStringSubmatch(rsp)
                        if len(matches) &gt;= 3 </span><span class="cov0" title="0">{
                                // If success and format is good
                                requestID := matches[1]
                                responseCode := matches[2]
                                // msgStoreRequest := ch.c.MessageStoreRequest()
                                msgStoreRequest := ch.c.GetInt("sms.msgstorerequest")
                                if msgStoreRequest == 1 || msgreq.Priority == 3 || msgreq.Priority == 4 </span><span class="cov0" title="0">{
                                        msgresponse := domain.MsgResponse{
                                                CommunicationID:  msgreq.CommunicationID,
                                                CompleteResponse: rsp,
                                                ResponseCode:     responseCode,
                                                ResponseText:     "Submitted Successfully",
                                                ReferenceID:      requestID,
                                        }
                                        _, _ = ch.svc.SaveResponse(ctx, &amp;msgresponse)
                                        // handleSuccess(ctx, msgresponse)
                                        rsp := response.NewCreateSMSResponse(&amp;msgresponse)
                                        apiRsp := response.CreateSMSAPIResponse{
                                                StatusCodeAndMessage: port.CreateSuccess,
                                                Data:                 rsp,
                                        }
                                        handleCreateSuccess(ctx, apiRsp)
                                        return
                                }</span>
                        }

                } else<span class="cov0" title="0"> {
                        // customError := CustomError{Message: "Invalid Gateway"}
                        // ch.vs.handleError(ctx, customError)
                        apierrors.HandleWithMessage(ctx, "Invalid Gateway")
                }</span>
        } else<span class="cov0" title="0"> {
                // handleSuccess(ctx, "Stored Successfully")
                apiRsp := response.CreateSMSAPIResponse{
                        StatusCodeAndMessage: port.CreateSuccess,
                        // Data:                 rsp,
                }
                handleCreateSuccess(ctx, apiRsp)
        }</span>
}
/*
func (ch *MgApplicationHandler) SendTestMessageOld(ctx *gin.Context, payload map[string]interface{}) {
        // url := "https://uat.cept.gov.in/sms/v1/msgrequest/create"
        url := "https://dev.cept.gov.in/bemsggateway/v1/msgrequest/create"
        // Convert payload to JSON
        jsonPayload, err := json.Marshal(payload)
        if err != nil {
                log.Error(nil, "Unable to read the payload in SendTestMessage function %s", err.Error())
                // ch.vs.handleError(ctx, errors.New("unable to read the payload"))
                apierrors.HandleMarshalError(ctx, err)
                return
        }
        tr := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        MinVersion:         tls.VersionTLS12,
                        InsecureSkipVerify: false,                       // Set to true only for testing; not recommended for production.
                        Renegotiation:      tls.RenegotiateOnceAsClient, // Adjust renegotiation settings.
                },
                DisableKeepAlives: true, // Disable keep-alive
        }

        client := &amp;http.Client{
                Transport: tr,
                Timeout:   30 * time.Second, // Adjust the timeout as needed
        }
        SMSResponse, err := client.Post(url, "application/json", bytes.NewBuffer(jsonPayload))
        if err != nil {
                log.Error(ctx, "Error calling SMS Provider URL: %s", err.Error())
                // ch.vs.handleError(ctx, errors.New(err.Error()))
                // apierrors.HandleErrorWithCustomMessage(ctx, "Error calling SMS Provider URL: ", err)
                apierrors.HandleErrorWithStatusCodeAndMessage(ctx, apierrors.HTTPErrorBadGateway, "Error calling SMS Provider URL: ", err)
                return
        }
        defer SMSResponse.Body.Close()
        if SMSResponse.StatusCode == http.StatusOK {
                // handleSuccess(ctx, "rsp")
                apiRsp := response.CreateSMSAPIResponse{
                        StatusCodeAndMessage: port.CreateSuccess,
                        // Data:                 rsp,
                }
                handleSuccess(ctx, apiRsp)
                return
        } else {
                // ch.vs.handleError(ctx, errors.New("unable to send the message"))
                apierrors.HandleWithMessage(ctx, "unable to send the message")
                return
        }

}

func (ch *MgApplicationHandler) SendTestMessage2(ctx *gin.Context, payload map[string]interface{}) (string, error) {

        url := "https://dev.cept.gov.in/bemsggateway/v1/msgrequest/create"

        // Convert payload to JSON
        jsonPayload, err := json.Marshal(payload)
        if err != nil {
                log.Error(ctx, "Marshalling failed in SendTestMessage function %s", err.Error())
                apierrors.HandleMarshalError(ctx, err)
                return "", fmt.Errorf("failed to marshal payload: %w", err)
        }

        tr := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        MinVersion:         tls.VersionTLS12,
                        InsecureSkipVerify: false,
                        Renegotiation:      tls.RenegotiateOnceAsClient,
                },
                DisableKeepAlives: true,
        }

        client := &amp;http.Client{
                Transport: tr,
                Timeout:   30 * time.Second,
        }

        // Send request to SMS provider
        SMSResponse, err := client.Post(url, "application/json", bytes.NewBuffer(jsonPayload))
        if err != nil {
                log.Error(ctx, "Error calling SMS Provider URL %s", err.Error())
                // apierrors.HandleErrorWithCustomMessage(ctx, "Error calling SMS Provider URL", err)
                apierrors.HandleErrorWithStatusCodeAndMessage(ctx, apierrors.HTTPErrorBadGateway, "Error calling SMS Provider URL: ", err)
                return "", fmt.Errorf("failed to send request to SMS provider: %w", err)
        }
        defer SMSResponse.Body.Close()

        // Check response status
        if SMSResponse.StatusCode != http.StatusOK {
                apierrors.HandleWithMessage(ctx, "unable to send the message")
                return "", fmt.Errorf("SMS provider returned status: %s", SMSResponse.Status)
        }

        // Parse and return the response body if needed
        body, err := io.ReadAll(SMSResponse.Body)
        if err != nil {
                log.Error(ctx, "Failed to read SMS provider response body %s", err.Error())
                return "", fmt.Errorf("failed to read SMS provider response: %w", err)
        }

        log.Info(ctx, "SMS sent successfully: %s", string(body))
        return string(body), nil
}

*/

func (ch *MgApplicationHandler) SendTestMessage(ctx *gin.Context, payload map[string]interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        // url := "https://dev.cept.gov.in/bemsggateway/v1/msgrequest/create"
        url := ch.c.GetString("client.baseurl")

        jsonPayload, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Unable to marshal payload in SendTestMessage function %s", err.Error())
                apierrors.HandleMarshalError(ctx, err)
                return nil, fmt.Errorf("failed to marshal payload: %w", err)
        }</span>

        <span class="cov8" title="1">tr := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{
                        MinVersion:         tls.VersionTLS12,
                        InsecureSkipVerify: false,
                        Renegotiation:      tls.RenegotiateOnceAsClient,
                },
                DisableKeepAlives: true,
        }

        client := &amp;http.Client{
                Transport: tr,
                Timeout:   30 * time.Second,
        }

        SMSResponse, err := client.Post(url, "application/json", bytes.NewBuffer(jsonPayload))
        if err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Error calling SMS Provider URL %s", err.Error())
                // apierrors.HandleErrorWithCustomMessage(ctx, "Error calling SMS Provider URL", err)
                apierrors.HandleErrorWithStatusCodeAndMessage(ctx, apierrors.HTTPErrorBadGateway, "Error calling SMS Provider URL: ", err)
                return nil, fmt.Errorf("failed to send request to SMS provider: %w", err)
        }</span>
        <span class="cov8" title="1">defer SMSResponse.Body.Close()

        if SMSResponse.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                apierrors.HandleWithMessage(ctx, "unable to send the message")
                return nil, fmt.Errorf("SMS provider returned status: %s", SMSResponse.Status)
        }</span>

        // Decoding the response JSON into a map for structured access
        <span class="cov8" title="1">var responseData map[string]interface{}
        if err := json.NewDecoder(SMSResponse.Body).Decode(&amp;responseData); err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Failed to decode SMS provider response body %s", err.Error())
                return nil, fmt.Errorf("failed to decode SMS provider response: %w", err)
        }</span>

        <span class="cov8" title="1">log.Info(ctx, "SMS sent successfully: %v", responseData)
        return responseData, nil</span>
}

/*
func (ch *MgApplicationHandler) CreateTestSMSHandlerOld(ctx *gin.Context) {
        payload := make(map[string]interface{})

        payload["application_id"] = "4"
        payload["facility_id"] = "facility1"
        payload["priority"] = 1
        payload["message_text"] = "Dear Customer, OTP for booking is 1234, please do not share it with anyone - INDPOST"
        payload["sender_id"] = "INPOST"
        payload["mobile_numbers"] = "9634294395"
        payload["entity_id"] = "1001081725895192800"
        payload["template_id"] = "1007344609998507114"

        ch.SendTestMessage(ctx, payload)
}
        */

type createTestSMSRequest struct {
        MobileNumber string `json:"mobile_number" binding:"required"` // Mobile number as request parameter
}

/*
func (ch *MgApplicationHandler) CreateTestSMSHandlerOld2(ctx *gin.Context) {

        var req createTestSMSRequest

        if err := ctx.ShouldBindJSON(&amp;req); err != nil {
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "JSON Binding failed for createTestSMSRequest: %s", err.Error())
                return
        }

        if err := validation.ValidateStruct(req); err != nil {
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for createTestSMSRequest: %s", err.Error())
                return
        }

        // Prepare the payload
        payload := map[string]interface{}{
                "application_id": "4",
                "facility_id":    "facility1",
                "priority":       1,
                "message_text":   "Dear Customer, OTP for booking is 1234, please do not share it with anyone - INDPOST",
                "sender_id":      "INPOST",
                "mobile_numbers": req.MobileNumber,
                "entity_id":      "1001081725895192800",
                "template_id":    "1007344609998507114",
        }

        // Send the SMS using SendTestMessage and capture the response or error
        rsp, err := ch.SendTestMessage(ctx, payload)
        if err != nil {
                log.Error(ctx, "Failed to send test SMS: %s", err.Error())
                apierrors.HandleError(ctx, err)
                return
        }

        // Return success response with SMS details
        apiRsp := response.TestSMSAPIResponse{
                //        StatusCodeAndMessage: port.CreateSuccess,
                // Message:              "Test SMS sent successfully",
                Data: rsp,
        }

        log.Debug(ctx, "CreateTestSMSHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)
}
        */

// CreateTestMessageHandler godoc
//
//        @Summary                Creates a test message request
//        @Description        Creates a new test message requests
//        @Tags                        SMS Request
//        @ID                                CreateTestSMSHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        createSMSRequest        body                createTestSMSRequest                true        "Creates Message request"
//        @Success                201                                        {object}        response.TestSMSAPIResponse        "Success"
//        @Failure                400                                        {object}        apierrors.APIErrorResponse        "Bad Request"
//        @Failure                401                                        {object}        apierrors.APIErrorResponse        "Unauthorized"
//        @Failure                403                                        {object}        apierrors.APIErrorResponse        "Forbidden"
//        @Failure                404                                        {object}        apierrors.APIErrorResponse        "Data not found"
//        @Failure                409                                        {object}        apierrors.APIErrorResponse        "Data conflict errpr"
//        @Failure                422                                        {object}        apierrors.APIErrorResponse        "Binding or Validation error"
//        @Failure                500                                        {object}        apierrors.APIErrorResponse        "Internal server error"
//        @Failure                502                                        {object}        apierrors.APIErrorResponse        "Bad Gateway"
//        @Failure                504                                        {object}        apierrors.APIErrorResponse        "Gateway Timeout"
//        @Router                        /test-sms-request [post]
func (ch *MgApplicationHandler) CreateTestSMSHandler(ctx *gin.Context) <span class="cov8" title="1">{
        var req createTestSMSRequest

        // Bind and validate JSON payload for mobile number
        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "JSON Binding failed for createTestSMSRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for createTestSMSRequest: %s", err.Error())
                return
        }</span>

        // Prepare the payload
        <span class="cov8" title="1">payload := map[string]interface{}{
                "application_id": "4",
                "facility_id":    "facility1",
                "priority":       1,
                "message_text":   "Dear Customer, OTP for booking is 1234, please do not share it with anyone - INDPOST",
                "sender_id":      "INPOST",
                "mobile_numbers": req.MobileNumber,
                "entity_id":      "1001081725895192800",
                "template_id":    "1007344609998507114",
                "gateway":        "1",
                "message_type":   "PM",
        }

        // Send the SMS using SendTestMessage and capture the response or error
        rsp, err := ch.SendTestMessage(ctx, payload)
        if err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Failed to send test SMS: %s", err.Error())
                apierrors.HandleError(ctx, err)
                return
        }</span>

        // apiRsp := response.TestSMSAPIResponse{
        //StatusCodeAndMessage: port.CreateSuccess,
        // Message:              "Test SMS sent successfully",
        // Data: rsp,
        // }

        // log.Debug(ctx, "CreateTestSMSHandler response: %v", apiRsp)
        // handleSuccess(ctx, apiRsp)
        <span class="cov8" title="1">log.Debug(ctx, "CreateTestSMSHandler response: %v", rsp)
        handleSuccess(ctx, rsp)</span>
}

type EditMgApplicationRequest struct {
        ApplicationID   uint64 `json:"application_id"`
        ApplicationName string `json:"application_name"`
        RequestType     string `json:"request_type"`
}

// type listApplicationsRequest struct {
//         Skip  uint64 `form:"skip" binding:"required,min=0" example:"0"`
//         Limit uint64 `form:"limit" binding:"required,min=5" example:"5"`
// }

type CustomError struct {
        Message string `json:"message"`
        Status  string `json:"status"`
}

func GenerateRandomString(length int) (string, error) <span class="cov8" title="1">{
        randomBytes := make([]byte, length)
        _, err := rand.Read(randomBytes)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">randomString := base64.URLEncoding.EncodeToString(randomBytes)[:length]
        return randomString, nil</span>
}

func SendSMSCDAC(username string, password string, message string, senderId string, mobileNumber string, secureKey string, templateId string, messageType string) (string, error) <span class="cov8" title="1">{
        log.Debug(nil, "Inside SendSMSCDAC function")
        var responseString string

        //Create an HTTP client with a custom TLS configuration
        // tr := &amp;http.Transport{
        //         TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: false},
        // }
        // client := &amp;http.Client{Transport: tr}

        //client := http.DefaultClient
        client := &amp;http.Client{}
        // Encrypt the password using MD5
        encryptedPassword, _ := MD5(password)
        //fmt.Println("192", encryptedPassword, username, senderId, message, secureKey)
        // Generate hash key
        hashKey := hashGenerator(username, senderId, message, secureKey)
        //fmt.Println("193 hashkey is:", hashKey)

        // var mobileNumberString []string
        // for _, num := range mobileNumber {
        //         mobileNumberString = append(mobileNumberString, strconv.FormatInt(num, 10))
        // }

        // // Join []string into a comma-separated string
        // mobileNumberParam := ""
        // if len(mobileNumberString) &gt; 0 {
        //         mobileNumberParam = mobileNumberString[0]
        //         for _, num := range mobileNumberString[1:] {
        //                 mobileNumberParam += "," + num
        //         }
        // }

        // Prepare the request parameters
        data := url.Values{}
        data.Set("username", username)
        data.Set("password", encryptedPassword)
        data.Set("mobileno", mobileNumber)
        data.Set("senderid", senderId)
        data.Set("content", message)
        if messageType == "UC" </span><span class="cov8" title="1">{
                data.Set("smsservicetype", "unicodemsg")
        }</span> else<span class="cov8" title="1"> {
                data.Set("smsservicetype", "singlemsg")
        }</span>
        <span class="cov8" title="1">data.Set("key", hashKey)
        data.Set("templateid", templateId)

        // Make the HTTP POST request
        url := "https://msdgweb.mgov.gov.in/esms/sendsmsrequestDLT"
        resp, err := client.PostForm(url, data)
        if err != nil </span><span class="cov0" title="0">{
                // fmt.Println("Error:", err)
                return "", err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Read the response body
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                // fmt.Println("Error reading response body:", err)
                return "", err
        }</span>

        // Convert the response body to a string
        <span class="cov8" title="1">responseString = string(body)
        // fmt.Println(responseString)
        log.Info(nil, "CDAC responseString is : %s", responseString)
        return responseString, nil</span>
}

func SendSMSNIC(username string, password string, message string, senderId string, mobileNumber string, entityId string, templateId string, messageType string) (string, error) <span class="cov8" title="1">{
        // Construct the base URL

        baseURL := "https://smsgw.sms.gov.in/failsafe/HttpLink"

        // var mobileNumberString []string
        // for _, num := range mobileNumber {
        //         mobileNumberString = append(mobileNumberString, strconv.FormatInt(num, 10))
        // }

        // // Join []string into a comma-separated string
        // mobileNumberParam := ""
        // if len(mobileNumberString) &gt; 0 {
        //         mobileNumberParam = mobileNumberString[0]
        //         for _, num := range mobileNumberString[1:] {
        //                 mobileNumberParam += "," + num
        //         }
        // }

        // Manually constructing the query string without URL encoding
        queryString := fmt.Sprintf("?username=%s&amp;pin=%s&amp;message=%s&amp;mnumber=%s&amp;signature=%s&amp;dlt_entity_id=%s&amp;dlt_template_id=%s&amp;msgType=%s",
                username, password, message, mobileNumber, senderId, entityId, templateId, messageType)

        // Append query string to the base URL
        fullURL := baseURL + queryString
        // fmt.Println(fullURL) // Printing the full URL for debugging
        // print(fullURL)
        req, err := http.NewRequest("POST", fullURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Set the Content-Type header to application/x-www-form-urlencoded

        // Execute the HTTP request
        <span class="cov8" title="1">client := &amp;http.Client{}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check the HTTP response status
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return "", fmt.Errorf("SMS Gateway returned non-OK status: %d %s", resp.StatusCode, resp.Status)
        }</span>

        // Read the response body
        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Convert the body to a string for further processing
        <span class="cov0" title="0">responseString := string(body)

        // Example processing of the response string
        // Here you can implement parsing logic based on the expected format of the response
        if strings.Contains(responseString, "Message Accepted") </span><span class="cov0" title="0">{
                // Extract the Request ID or other relevant information from the response
                // For simplicity, this example just returns the entire response string
                return responseString, nil
        }</span> else<span class="cov0" title="0"> {
                // Handle unexpected response format or error messages from the SMS gateway
                return "", fmt.Errorf("unexpected response from sms gateway: %s", responseString)
        }</span>
}

func hashGenerator(userName string, senderId string, content string, secureKey string) string <span class="cov8" title="1">{
        finalString := userName + senderId + content + secureKey

        hashGen := finalString
        md := sha512.New()
        md.Write([]byte(hashGen))
        byteData := md.Sum(nil)

        sb := ""
        for _, b := range byteData </span><span class="cov8" title="1">{
                sb += fmt.Sprintf("%02x", b)
        }</span>

        <span class="cov8" title="1">return sb</span>
}

func MD5(text string) (string, error) <span class="cov8" title="1">{
        // Create a new SHA-1 hash instance
        hash := sha1.New()

        // Write the text to the hash
        _, err := io.WriteString(hash, text)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Get the hash sum as a byte slice
        <span class="cov8" title="1">hashInBytes := hash.Sum(nil)

        // Convert the byte slice to a hexadecimal string
        md5String := convertedToHex(hashInBytes)

        return md5String, nil</span>
}

func convertedToHex(data []byte) string <span class="cov8" title="1">{
        var buf []rune

        for i := 0; i &lt; len(data); i++ </span><span class="cov8" title="1">{
                halfOfByte := (data[i] &gt;&gt; 4) &amp; 0x0F
                twoHalfBytes := 0

                for twoHalfBytes &lt; 2 </span><span class="cov8" title="1">{
                        if 0 &lt;= halfOfByte &amp;&amp; halfOfByte &lt;= 9 </span><span class="cov8" title="1">{
                                buf = append(buf, rune('0'+halfOfByte))
                        }</span> else<span class="cov8" title="1"> {
                                buf = append(buf, rune('a'+(halfOfByte-10)))
                        }</span>

                        <span class="cov8" title="1">halfOfByte = data[i] &amp; 0x0F
                        twoHalfBytes++</span>
                }
        }

        <span class="cov8" title="1">return string(buf)</span>
}

/*
func convertMap(mapData map[string]interface{}) map[string]string {
        result := make(map[string]string)

        for key, value := range mapData {
                // Convert the value to a string
                strValue, ok := value.(string)
                if !ok {
                        // Handle the case where the value cannot be converted to a string
                        strValue = fmt.Sprintf("%v", value)
                }

                // Add the key-value pair to the result map
                result[key] = strValue
        }

        return result
}
*/

func (ce CustomError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("{Message: %s}", ce.Message)
}</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "MgApplication/core/domain"
        "MgApplication/core/port"
        "MgApplication/handler/response"
        repo "MgApplication/repo/postgres"
        "math"

        "encoding/json"

        // _ "time"

        "github.com/gin-gonic/gin"
        config "MgApplication/api-config"
        apierrors "MgApplication/api-errors"
        log "MgApplication/api-log"
        validation "MgApplication/api-validation"
)

// MgApplication Handler represents the HTTP handler for MgApplication related requests
type ProviderHandler struct {
        svc *repo.ProviderRepository
        c   *config.Config
}

// MgApplication Handler creates a new MgApplicatPion Handler instance
func NewProviderHandler(svc *repo.ProviderRepository, c *config.Config) *ProviderHandler <span class="cov8" title="1">{
        return &amp;ProviderHandler{
                svc,
                c,
        }
}</span>

type createMessageProviderRequest struct {
        ProviderName      string          `json:"provider_name" validate:"required" example:"Test Provider"`
        ShortName         string          `json:"short_name" validate:"required" example:"TP"`
        Services          string          `json:"services" validate:"required" example:"1,2,3,4"`
        ConfigurationKeys json.RawMessage `json:"configuration_keys" validate:"required" swaggertype:"string" example:"[{\"keyname\":\"key1\",\"keyvalue\":\"keyvalue1\"},{\"keyname\":\"key2\",\"keyvalue\":\"keyvalue2\"}]"`
        //ConfigurationKeys interface{} `json:"configuration_keys" validate:"required"`
        Status bool `json:"status" validate:"required" example:"true"`
}

// CreateMessageProvider godoc
//
//        @Summary                Creates a Message Service Provider
//        @Description        Creates a new Message Service Provider
//        @Tags                        Providers
//        @ID                                CreateMessageProviderHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        createMessageProviderRequest        body                createMessageProviderRequest                        true        "Create Message Service Provider"
//        @Success                201                                                                {object}        response.CreateSMSProviderAPIResponse        "Message Service Provider is created"
//        @Failure                400                                                                {object}        apierrors.APIErrorResponse                                "Bad Request"
//        @Failure                401                                                                {object}        apierrors.APIErrorResponse                                "Unauthorized"
//        @Failure                403                                                                {object}        apierrors.APIErrorResponse                                "Forbidden"
//        @Failure                404                                                                {object}        apierrors.APIErrorResponse                                "Data not found"
//        @Failure                409                                                                {object}        apierrors.APIErrorResponse                                "Data conflict errpr"
//        @Failure                422                                                                {object}        apierrors.APIErrorResponse                                "Binding or Validation error"
//        @Failure                500                                                                {object}        apierrors.APIErrorResponse                                "Internal server error"
//        @Failure                502                                                                {object}        apierrors.APIErrorResponse                                "Bad Gateway"
//        @Failure                504                                                                {object}        apierrors.APIErrorResponse                                "Gateway Timeout"
//        @Router                        /sms-providers [post]
func (ph *ProviderHandler) CreateMessageProviderHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req createMessageProviderRequest

        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Binding failed for createMessageProviderRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for createMessageProviderRequest: %s", err.Error())
                return
        }</span>

        // if !ph.vs.isValidRequestType(req.Services) {
        //         apierrors.HandleWithMessage(ctx, "invalid values for the services type")
        //         log.Error(ctx, "Validation failed for createMessageProviderRequest: %s", "invalid services")
        //         return
        // }

        <span class="cov8" title="1">var aStatus int
        if req.Status </span><span class="cov8" title="1">{
                aStatus = 1
        }</span> else<span class="cov0" title="0"> {
                aStatus = 0
        }</span>

        <span class="cov8" title="1">msgproviderreq := domain.MsgProvider{
                ProviderName:      req.ProviderName,
                ShortName:         req.ShortName,
                Services:          req.Services,
                ConfigurationKeys: req.ConfigurationKeys,
                Status:            aStatus,
        }

        provider, err := ph.svc.CreateMessageProviderRepo(ctx, &amp;msgproviderreq)
        if err != nil </span><span class="cov8" title="1">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in CreateMsgProviderRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">rsp := response.NewCreateSMSProviderResponse(&amp;provider)
        apiRsp := response.CreateSMSProviderAPIResponse{
                StatusCodeAndMessage: port.CreateSuccess,
                Data:                 rsp,
        }

        log.Debug(ctx, "CreateMessageProviderHandler response: %v", apiRsp)
        handleCreateSuccess(ctx, apiRsp)</span>
}

type listMessageProviderRequest struct {
        Status bool `form:"status" validate:"omitempty" example:"true"`
        port.MetaDataRequest
}

// ListMessageProviders godoc
//
//        @Summary                Get Message Providers
//        @Description        Lists all message service providers
//        @Tags                        Providers
//        @ID                                ListMessageProvidersHandler
//        @Produce                json
//        @Param                        listMessageProviderRequest        query                listMessageProviderRequest                                false        "Get Provider Request (by Query)"
//        @Success                200                                                        {object}        response.ListSMSProvidersAPIResponse        "All Message service providers are retrieved"
//        @Failure                400                                                        {object}        apierrors.APIErrorResponse                                "Bad Request"
//        @Failure                401                                                        {object}        apierrors.APIErrorResponse                                "Unauthorized"
//        @Failure                403                                                        {object}        apierrors.APIErrorResponse                                "Forbidden"
//        @Failure                404                                                        {object}        apierrors.APIErrorResponse                                "Data not found"
//        @Failure                409                                                        {object}        apierrors.APIErrorResponse                                "Data conflict errpr"
//        @Failure                422                                                        {object}        apierrors.APIErrorResponse                                "Binding or Validation error"
//        @Failure                500                                                        {object}        apierrors.APIErrorResponse                                "Internal server error"
//        @Failure                502                                                        {object}        apierrors.APIErrorResponse                                "Bad Gateway"
//        @Failure                504                                                        {object}        apierrors.APIErrorResponse                                "Gateway Timeout"
//        @Router                        /sms-providers [get]
func (ph *ProviderHandler) ListMessageProvidersHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req listMessageProviderRequest
        if err := ctx.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for listMessageProviderRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for listMessageProviderRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if req.Limit == 0 &amp;&amp; req.Skip == 0 </span><span class="cov0" title="0">{
                req.Limit = math.MaxInt32
        }</span>

        <span class="cov8" title="1">msgproviderreq := domain.ListMessageProviders{
                Status: req.Status,
        }

        providers, err := ph.svc.ListMessageProvidersRepo(ctx, msgproviderreq, req.MetaDataRequest)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in ListProvidersRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">total := len(providers)
        rsp := response.NewListSMSProvidersResponse(providers)
        metadata := port.NewMetaDataResponse(req.Skip, req.Limit, total)

        apiRsp := response.ListSMSProvidersAPIResponse{
                StatusCodeAndMessage: port.ListSuccess,
                MetaDataResponse:     metadata,
                Data:                 rsp,
        }

        log.Debug(ctx, "ListMessageProvidersHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}

type fetchMessageProviderRequest struct {
        ProviderID uint64 `uri:"provider-id" validate:"required,numeric" example:"3"`
}

// FetchMessageProvider godoc
//
//        @Summary                Get Message Service Provider by ProviderID
//        @Description        Fetches Message Service Provider by ProviderID
//        @Tags                        Providers
//        @ID                                FetchMessageProviderHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        fetchMessageProviderRequest        path                fetchMessageProviderRequest                                true        "Get Provider Request"
//        @Success                200                                                        {object}        response.FetchSMSProviderAPIResponse        "Message Provider is retrieved by ProviderID"
//        @Failure                400                                                        {object}        apierrors.APIErrorResponse                                "Bad Request"
//        @Failure                401                                                        {object}        apierrors.APIErrorResponse                                "Unauthorized"
//        @Failure                403                                                        {object}        apierrors.APIErrorResponse                                "Forbidden"
//        @Failure                404                                                        {object}        apierrors.APIErrorResponse                                "Data not found"
//        @Failure                409                                                        {object}        apierrors.APIErrorResponse                                "Data conflict errpr"
//        @Failure                422                                                        {object}        apierrors.APIErrorResponse                                "Binding or Validation error"
//        @Failure                500                                                        {object}        apierrors.APIErrorResponse                                "Internal server error"
//        @Failure                502                                                        {object}        apierrors.APIErrorResponse                                "Bad Gateway"
//        @Failure                504                                                        {object}        apierrors.APIErrorResponse                                "Gateway Timeout"
//        @Router                        /sms-providers/{provider-id} [get]
func (ph *ProviderHandler) FetchMessageProviderHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req fetchMessageProviderRequest

        if err := ctx.ShouldBindUri(&amp;req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for fetchMessageProviderRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for fetchMessageProviderRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">msgproviderreq := domain.MsgProvider{
                ProviderID: req.ProviderID,
        }

        provider, err := ph.svc.FetchMessageProviderRepo(ctx, &amp;msgproviderreq)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in GetProviderbyIDRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">total := len(provider)
        rsp := response.NewFetchSMSProviderResponse(provider)
        metadata := port.NewMetaDataResponse(0, 0, total)

        apiRsp := response.FetchSMSProviderAPIResponse{
                StatusCodeAndMessage: port.FetchSuccess,
                MetaDataResponse:     metadata,
                Data:                 rsp,
        }

        log.Debug(ctx, "FetchMessageProviderHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}

type updateMessageProviderRequest struct {
        ProviderID        uint64          `uri:"provider-id"  validate:"required,numeric" example:"3" json:"-"`
        ProviderName      string          `json:"provider_name" validate:"required" example:"Test Provider"`
        Services          string          `json:"services" validate:"required,services" example:"1,2,3,4"`
        ConfigurationKeys json.RawMessage `json:"configuration_keys"`
        Status            bool            `json:"status" validate:"required" example:"true"`
}

// UpdateMessageProvider godoc
//
//        @Summary                Edits an existing Message Provider
//        @Description        Allows editing of an existing Message Provider
//        @Tags                        Providers
//        @ID                                UpdateMessageProviderHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        provider-id                                                path                uint64                                                                        true        "Edit Message Provider Request"
//        @Param                        updateMessageProviderRequest        body                updateMessageProviderRequest                        true        "Edit Message Provider Request"
//        @Success                200                                                                {object}        response.UpdateSMSProviderAPIResponse        "Message Provider is modified"
//        @Failure                400                                                                {object}        apierrors.APIErrorResponse                                "Bad Request"
//        @Failure                401                                                                {object}        apierrors.APIErrorResponse                                "Unauthorized"
//        @Failure                403                                                                {object}        apierrors.APIErrorResponse                                "Forbidden"
//        @Failure                404                                                                {object}        apierrors.APIErrorResponse                                "Data not found"
//        @Failure                409                                                                {object}        apierrors.APIErrorResponse                                "Data conflict errpr"
//        @Failure                422                                                                {object}        apierrors.APIErrorResponse                                "Binding or Validation error"
//        @Failure                500                                                                {object}        apierrors.APIErrorResponse                                "Internal server error"
//        @Failure                502                                                                {object}        apierrors.APIErrorResponse                                "Bad Gateway"
//        @Failure                504                                                                {object}        apierrors.APIErrorResponse                                "Gateway Timeout"
//        @Router                        /sms-providers/{provider-id} [put]
func (ph *ProviderHandler) UpdateMessageProviderHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req updateMessageProviderRequest

        if err := ctx.ShouldBindUri(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "URI Binding failed for updateMessageProviderRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "JSON Binding failed for updateMessageProviderRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for updateMessageProviderRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">var aStatus int
        if req.Status </span><span class="cov8" title="1">{
                aStatus = 1
        }</span> else<span class="cov0" title="0"> {
                aStatus = 0
        }</span>

        <span class="cov8" title="1">msgproviderreq := domain.MsgProvider{
                ProviderID:   req.ProviderID,
                ProviderName: req.ProviderName,
                Services:     req.Services,
                Status:       aStatus,
        }

        provider, err := ph.svc.UpdateMessageProviderRepo(ctx, &amp;msgproviderreq)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in EditMsgProviderRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">rsp := response.NewUpdateSMSProviderResponse(&amp;provider)
        apiRsp := response.UpdateSMSProviderAPIResponse{
                StatusCodeAndMessage: port.UpdateSuccess,
                Data:                 rsp,
        }

        log.Debug(ctx, "UpdateMessageProviderHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}

type toggleMessageProviderStatusRequest struct {
        ProviderID uint64 `uri:"provider-id" validate:"required,numeric" example:"3"`
}

// ToggleMessageProviderStatus godoc
//
//        @Summary                Modifies the status of Message Provider
//        @Description        Toggles the status of Message Provider
//        @Tags                        Providers
//        @ID                                ToggleMessageProviderStatusHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        toggleMessageProviderStatusRequest        path                toggleMessageProviderStatusRequest                        true        "Message Provider Status Request"
//        @Success                200                                                                        {object}        response.ToggleProviderStatusAPIResponse        "Message Provider status is modified"
//        @Failure                400                                                                        {object}        apierrors.APIErrorResponse                                        "Bad Request"
//        @Failure                401                                                                        {object}        apierrors.APIErrorResponse                                        "Unauthorized"
//        @Failure                403                                                                        {object}        apierrors.APIErrorResponse                                        "Forbidden"
//        @Failure                404                                                                        {object}        apierrors.APIErrorResponse                                        "Data not found"
//        @Failure                409                                                                        {object}        apierrors.APIErrorResponse                                        "Data conflict errpr"
//        @Failure                422                                                                        {object}        apierrors.APIErrorResponse                                        "Binding or Validation error"
//        @Failure                500                                                                        {object}        apierrors.APIErrorResponse                                        "Internal server error"
//        @Failure                502                                                                        {object}        apierrors.APIErrorResponse                                        "Bad Gateway"
//        @Failure                504                                                                        {object}        apierrors.APIErrorResponse                                        "Gateway Timeout"
//        @Router                        /sms-providers/{provider-id}/status [put]
func (ch *ProviderHandler) ToggleMessageProviderStatusHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req toggleMessageProviderStatusRequest

        if err := ctx.ShouldBindUri(&amp;req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for toggleMessageProviderStatusRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for updateMessageProviderRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">msgproviderreq := domain.StatusProvider{
                ProviderID: req.ProviderID,
        }

        rsp, err := ch.svc.ToggleMessageProviderStatusRepo(ctx, &amp;msgproviderreq)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in StatusMsgProviderRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">apiRsp := response.ToggleProviderStatusAPIResponse{
                StatusCodeAndMessage: port.UpdateSuccess,
                //MetaDataResponse:     metadata,
                Data: rsp,
        }

        log.Debug(ctx, "ToggleMessageProviderStatusHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "MgApplication/core/domain"
        "MgApplication/core/port"
        "MgApplication/handler/response"
        repo "MgApplication/repo/postgres"
        "math"
        "time"

        // _ "time"

        "github.com/gin-gonic/gin"
        config "MgApplication/api-config"
        apierrors "MgApplication/api-errors"
        log "MgApplication/api-log"
        validation "MgApplication/api-validation"
)

type ReportsHandler struct {
        svc *repo.ReportsRepository
        c   *config.Config
}

func NewReportsHandler(svc *repo.ReportsRepository, c *config.Config) *ReportsHandler <span class="cov8" title="1">{
        return &amp;ReportsHandler{
                svc,
                c,
        }
}</span>

// SMSDashboard godoc
//
//        @Summary                Get SMS Dashboard data
//        @Description        Fetches SMS Dashboard data
//        @Tags                        Reports
//        @ID                                SMSDashboardHandler
//        @Produce                json
//        @Success                200        {object}        response.SMSDashboardAPIResponse        "SMS Dashboard data is retrieved"
//        @Failure                400        {object}        apierrors.APIErrorResponse                        "Bad Request"
//        @Failure                401        {object}        apierrors.APIErrorResponse                        "Unauthorized"
//        @Failure                403        {object}        apierrors.APIErrorResponse                        "Forbidden"
//        @Failure                404        {object}        apierrors.APIErrorResponse                        "Data not found"
//        @Failure                409        {object}        apierrors.APIErrorResponse                        "Data conflict errpr"
//        @Failure                422        {object}        apierrors.APIErrorResponse                        "Binding or Validation error"
//        @Failure                500        {object}        apierrors.APIErrorResponse                        "Internal server error"
//        @Failure                502        {object}        apierrors.APIErrorResponse                        "Bad Gateway"
//        @Failure                504        {object}        apierrors.APIErrorResponse                        "Gateway Timeout"
//        @Router                        /sms-dashboard [get]
func (ch *ReportsHandler) SMSDashboardHandler(ctx *gin.Context) <span class="cov8" title="1">{

        data, err := ch.svc.SMSDashboardRepo(ctx)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in SMSDashboardRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">rsp := response.NewSMSDashboardResponse(&amp;data)
        apiRsp := response.SMSDashboardAPIResponse{
                StatusCodeAndMessage: port.FetchSuccess,
                //MetaDataResponse:     metadata,
                Data: rsp,
        }

        log.Debug(ctx, "SMSDashboardHandler Response: %v ", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}

type sentSMSStatusReportRequest struct {
        FromDate string `form:"from-date" validate:"required,date_dd_mm_yyyy" example:"01-01-2008"`
        ToDate   string `form:"to-date" validate:"required,date_dd_mm_yyyy" example:"18-06-2024"`
        port.MetaDataRequest
}

// SentSMSStatusReport godoc
//
//        @Summary                Get all SMS requests
//        @Description        Fetches all SMS requests
//        @Tags                        Reports
//        @ID                                SentSMSStatusReportHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        sentSMSStatusReportRequest        query                sentSMSStatusReportRequest                                true        "SMS Report Request"
//        @Success                200                                                        {object}        response.SMSSentStatusReportAPIResponse        "All message requests are retrieved"
//        @Failure                400                                                        {object}        apierrors.APIErrorResponse                                "Bad Request"
//        @Failure                401                                                        {object}        apierrors.APIErrorResponse                                "Unauthorized"
//        @Failure                403                                                        {object}        apierrors.APIErrorResponse                                "Forbidden"
//        @Failure                404                                                        {object}        apierrors.APIErrorResponse                                "Data not found"
//        @Failure                409                                                        {object}        apierrors.APIErrorResponse                                "Data conflict errpr"
//        @Failure                422                                                        {object}        apierrors.APIErrorResponse                                "Binding or Validation error"
//        @Failure                500                                                        {object}        apierrors.APIErrorResponse                                "Internal server error"
//        @Failure                502                                                        {object}        apierrors.APIErrorResponse                                "Bad Gateway"
//        @Failure                504                                                        {object}        apierrors.APIErrorResponse                                "Gateway Timeout"
//        @Router                        /sms-sent-status-report [get]
func (ch *ReportsHandler) SentSMSStatusReportHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req sentSMSStatusReportRequest

        if err := ctx.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for sentSMSStatusReportRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for sentSMSStatusReportRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if req.Limit == 0 &amp;&amp; req.Skip == 0 </span><span class="cov0" title="0">{
                req.Limit = math.MaxInt32
        }</span>

        <span class="cov8" title="1">fromDate, _ := time.Parse("02-01-2006", req.FromDate)
        toDate, _ := time.Parse("02-01-2006", req.ToDate)
        if toDate.Before(fromDate) </span><span class="cov0" title="0">{
                apierrors.HandleWithMessage(ctx, " to_date should be after from_date")
                log.Error(ctx, "to_date should be after from_date")
                return
        }</span>

        <span class="cov8" title="1">smsreport, err := ch.svc.SMSSentStatusReportRepo(ctx, fromDate, toDate, req.MetaDataRequest)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in SMSSentStatusReportRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">total := len(smsreport)
        rsp := response.NewSMSSentStatusReportResponse(smsreport)
        metadata := port.NewMetaDataResponse(req.Skip, req.Limit, total)

        apiRsp := response.SMSSentStatusReportAPIResponse{
                StatusCodeAndMessage: port.ListSuccess,
                MetaDataResponse:     metadata,
                Data:                 rsp,
        }

        log.Debug(ctx, "SentSMSStatusReportHandler Response: %v ", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}

type aggregateSMSUsageReportRequest struct {
        FromDate   string `form:"from-date" validate:"required,date_dd_mm_yyyy" example:"01-01-2008"`
        ToDate     string `form:"to-date" validate:"required,date_dd_mm_yyyy" example:"18-06-2024"`
        ReportType int8   `form:"report-type" validate:"required" example:"1"`
        port.MetaDataRequest
}

// AggregateSMSUsageReport godoc
//
//        @Summary                Get Aggregate SMS Usage Report
//        @Description        Fetches SMS Aggregate report Applicationwise, Templatewise and Providerwise
//        @Tags                        Reports
//        @ID                                AggregateSMSUsageReportHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        aggregateSMSUsageReportRequest        query                aggregateSMSUsageReportRequest                        true        "SMS Aggregate Report Request"
//        @Success                200                                                                {object}        response.AggregateSMSReportAPIResponse        "SMS Aggregate report is retrieved"
//        @Failure                400                                                                {object}        apierrors.APIErrorResponse                                "Bad Request"
//        @Failure                401                                                                {object}        apierrors.APIErrorResponse                                "Unauthorized"
//        @Failure                403                                                                {object}        apierrors.APIErrorResponse                                "Forbidden"
//        @Failure                404                                                                {object}        apierrors.APIErrorResponse                                "Data not found"
//        @Failure                409                                                                {object}        apierrors.APIErrorResponse                                "Data conflict errpr"
//        @Failure                422                                                                {object}        apierrors.APIErrorResponse                                "Binding or Validation error"
//        @Failure                500                                                                {object}        apierrors.APIErrorResponse                                "Internal server error"
//        @Failure                502                                                                {object}        apierrors.APIErrorResponse                                "Bad Gateway"
//        @Failure                504                                                                {object}        apierrors.APIErrorResponse                                "Gateway Timeout"
//        @Router                        /aggregate-sms-report [get]
func (ch *ReportsHandler) AggregateSMSUsageReportHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req aggregateSMSUsageReportRequest

        if err := ctx.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for aggregateSMSUsageReportRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for aggregateSMSUsageReportRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if req.Limit == 0 &amp;&amp; req.Skip == 0 </span><span class="cov0" title="0">{
                req.Limit = math.MaxInt32
        }</span>

        <span class="cov8" title="1">fromDate, _ := time.Parse("02-01-2006", req.FromDate)
        toDate, _ := time.Parse("02-01-2006", req.ToDate)
        if toDate.Before(fromDate) </span><span class="cov0" title="0">{
                apierrors.HandleWithMessage(ctx, "to_date should be after from_date")
                log.Error(ctx, "to_date should be after from_date")
                return
        }</span>

        <span class="cov8" title="1">var smsreport []domain.SMSAggregateReport

        var err error
        switch req.ReportType </span>{
        case 1:<span class="cov8" title="1">
                smsreport, err = ch.svc.AppwiseSMSUsageReportRepo(ctx, fromDate, toDate, req.MetaDataRequest)
                if err != nil </span><span class="cov0" title="0">{
                        apierrors.HandleDBError(ctx, err)
                        log.Error(ctx, "Error in AppwiseSMSUsageReportRepo: %s", err.Error())
                        return
                }</span>

        case 2:<span class="cov8" title="1">
                smsreport, err = ch.svc.TemplatewiseSMSUsageReportRepo(ctx, fromDate, toDate, req.MetaDataRequest)
                if err != nil </span><span class="cov0" title="0">{
                        apierrors.HandleDBError(ctx, err)
                        log.Error(ctx, "Error in TemplatewiseSMSUsageReportRepo: %s", err.Error())
                        return
                }</span>

        case 3:<span class="cov8" title="1">
                smsreport, err = ch.svc.ProviderwiseSMSUsageReportRepo(ctx, fromDate, toDate, req.MetaDataRequest)
                if err != nil </span><span class="cov0" title="0">{
                        apierrors.HandleDBError(ctx, err)
                        log.Error(ctx, "Error in ProviderwiseSMSUsageReportRepo: %s", err.Error())
                        return
                }</span>
        default:<span class="cov0" title="0">
                apierrors.HandleWithMessage(ctx, "Invalid report type. Must be 1, 2 or 3")
                log.Error(ctx, "Invalid report type: %d", req.ReportType)
                return</span>
        }

        <span class="cov8" title="1">total := uint64(len(smsreport))
        rsp := response.NewAggregateSMSReportResponse(smsreport)
        metadata := port.NewMetaDataResponse(req.Skip, req.Limit, int(total))

        apiRsp := response.AggregateSMSReportAPIResponse{
                StatusCodeAndMessage: port.ListSuccess,
                MetaDataResponse:     metadata,
                Data:                 rsp,
        }

        log.Debug(ctx, "AggregateSMSUsageReportHandler Response: %v ", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
)

/*

// response represents a response body format
type Response struct {
        Success bool   `json:"success" example:"true"`
        Message string `json:"message" example:"Success"`
        Data    any    `json:"data,omitempty"`
}

// newResponse is a helper function to create a response body
func newResponse(success bool, message string, data any) Response {
        return Response{
                Success: success,
                Message: message,
                Data:    data,
        }
}

// errorResponse represents an error response body format
type errorResponse struct {
        Success bool   `json:"success" example:"false"`
        Message string `json:"message" example:"Error message"`
}


type MsgApplicationResponse struct {
        ApplicationID   uint64 `json:"application_id"`
        ApplicationName string `json:"application_name"`
        //ProductIDs      string    `json:"product_ids"`
        RequestType string `json:"request_type"`
        //CallbackUrl     string    `json:"callback_url"`
        //WhitelistedIp   string    `json:"whitelisted_ip"`
        SecretKey   string    `json:"secret_key"`
        CreatedDate time.Time `json:"created_date"`
        UpdatedDate time.Time `json:"updated_date"`
        Status      int       `json:"status" db:"status_cd"`
}

type EditMsgApplicationResponse struct {
        ApplicationID   uint64 `json:"application_id"`
        ApplicationName string `json:"application_name"`
        //ProductIDs      string    `json:"product_ids"`
        RequestType string `json:"request_type"`
        //CallbackUrl     string    `json:"callback_url"`
        //WhitelistedIp   string    `json:"whitelisted_ip"`
        UpdatedDate time.Time `json:"updated_date"`
}
type MsgProviderResponse struct {
        ProviderID        uint64          `json:"provider_id"`
        ProviderName      string          `json:"provider_name"`
        ShortName         string          `json:"short_name"`
        Services          string          `json:"services"`
        ConfigurationKeys json.RawMessage `json:"configuration_keys"`
        //ConfigurationKeys interface{} `json:"configuration_keys"`
        Status int `json:"status"`
}

type EditMsgProviderResponse struct {
        ProviderID        uint64          `json:"provider_id"`
        ProviderName      string          `json:"provider_name"`
        Services          string          `json:"services"`
        ConfigurationKeys json.RawMessage `json:"configuration_keys"`
        //ConfigurationKeys interface{} `json:"configuration_keys"`
        Status int `json:"status"`
}
*/

// type MaintainTemplateResponse struct {
//         TemplateLocalID uint64 `json:"template_local_id"`
//         ApplicationID   string `json:"application_id"`
//         TemplateName    string `json:"template_name"`
//         TemplateFormat  string `json:"template_format"`
//         SenderID        string `json:"sender_id"`
//         EntityID        string `json:"entity_id"`
//         TemplateID           string `json:"template_id"`
//         Gateway         string `json:"gateway"`
//         Status          bool   `json:"status"`
// }

// //new office response is a helper function to create a response body for handling office details data

//        func newMaintainTemplate(mtemplate *domain.MaintainTemplate) MaintainTemplateResponse {
//                return MaintainTemplateResponse{
//                        ApplicationID:  mtemplate.ApplicationID,
//                        TemplateFormat: mtemplate.TemplateFormat,
//                        EntityID:       mtemplate.EntityID,
//                        TemplateID:          mtemplate.TemplateID,
//                        Gateway:        mtemplate.Gateway,
//                }
//        }
/*
func newMsgApplicationResponse(msgappres *domain.MsgApplications) MsgApplicationResponse {
        return MsgApplicationResponse{
                ApplicationID:   msgappres.ApplicationID,
                ApplicationName: msgappres.ApplicationName,

                RequestType: msgappres.RequestType,

                SecretKey:   msgappres.SecretKey,
                CreatedDate: msgappres.CreatedDate,
                UpdatedDate: msgappres.UpdatedDate,
                Status:      msgappres.Status,
        }
}

func newMsgProviderResponse(msgproviderres *domain.MsgProvider) MsgProviderResponse {
        return MsgProviderResponse{
                ProviderID:   msgproviderres.ProviderID,
                ProviderName: msgproviderres.ProviderName,
                ShortName:    msgproviderres.ShortName,

                Services:          msgproviderres.Services,
                ConfigurationKeys: msgproviderres.ConfigurationKeys,
                Status:            msgproviderres.Status,
        }
}
func editMsgProviderResponse(msgproviderres *domain.MsgProvider) EditMsgProviderResponse {
        return EditMsgProviderResponse{
                ProviderID:   msgproviderres.ProviderID,
                ProviderName: msgproviderres.ProviderName,
                Services:     msgproviderres.Services,
                Status:       msgproviderres.Status,
        }
}
func EditMsgApplicationsResponse(msgappres *domain.EditApplication) EditMsgApplicationResponse {
        return EditMsgApplicationResponse{
                ApplicationID:   msgappres.ApplicationID,
                ApplicationName: msgappres.ApplicationName,

                RequestType: msgappres.RequestType,

                UpdatedDate: msgappres.UpdatedDate,
        }
}


// newErrorResponse is a helper function to create an error response body
func newErrorResponse(message string) errorResponse {
        return errorResponse{
                Success: false,
                Message: message,
        }
}
        

// meta represents metadata for a paginated response
type meta struct {
        Total uint64 `json:"total" example:"100"`
        Limit uint64 `json:"limit" example:"10"`
        Skip  uint64 `json:"skip" example:"0"`
}

// newMeta is a helper function to create metadata for a paginated response
func newMeta(total, limit, skip uint64) meta {
        return meta{
                Total: total,
                Limit: limit,
                Skip:  skip,
        }
}

*/
// MgApplication Response represents a MgApplication response body

type MgApplicationResponse struct {
        ApplicationID   uint64 `json:"APPLICATION_ID"`
        ApplicationName string `json:"APPLICATION_NAME"`
        ProductIDs      string `json:"PRODUCT_IDS"`
        RequestType     string `json:"REQUEST_TYPE"`
        //CallbackUrl     string    `json:"CALLBACK_URL"`
        //WhitelistedIp   string    `json:"WHITELISTED_IP"`
        SecretKey   string    `json:"SECRET_KEY"`
        CreatedDate time.Time `json:"CREATED_DATE"`
        UpdatedDate time.Time `json:"UPDATED_DATE"`
        Status      int       `json:"STATUS"`
}
type EditMgApplicationResponse struct {
        ApplicationID   uint64 `json:"application_id"`
        ApplicationName string `json:"application_name"`
        ProductIDs      string `json:"product_ids"`
        RequestType     string `json:"request_type"`
}

/*
func EditMgApplicationsResponse(pgappres *domain.EditApplication) EditMgApplicationResponse {
        return EditMgApplicationResponse{
                ApplicationID:   pgappres.ApplicationID,
                ApplicationName: pgappres.ApplicationName,

                RequestType: pgappres.RequestType,
        }
}


// errorStatusMap is a map of defined error messages and their corresponding http status codes
// var errorStatusMap = map[error]int{
//         port.ErrDataNotFound:               http.StatusNotFound,
//         port.ErrConflictingData:            http.StatusConflict,
//         port.ErrInvalidCredentials:         http.StatusUnauthorized,
//         port.ErrUnauthorized:               http.StatusUnauthorized,
//         port.ErrEmptyAuthorizationHeader:   http.StatusUnauthorized,
//         port.ErrInvalidAuthorizationHeader: http.StatusUnauthorized,
//         port.ErrInvalidAuthorizationType:   http.StatusUnauthorized,
//         port.ErrInvalidToken:               http.StatusUnauthorized,
//         port.ErrExpiredToken:               http.StatusUnauthorized,
//         port.ErrForbidden:                  http.StatusForbidden,
//         port.ErrNoUpdatedData:              http.StatusBadRequest,
//         port.ErrInsufficientStock:          http.StatusBadRequest,
//         port.ErrInsufficientPayment:        http.StatusBadRequest,
// }

// validationError sends an error response for some specific request validation error
func validationError(ctx *gin.Context, err error) {
        ctx.JSON(http.StatusBadRequest, err)
}
*/
// handleError determines the status code of an error and returns a JSON response with the error message and status code
// func handleError(ctx *gin.Context, err error) {
//         statusCode, ok := errorStatusMap[err]
//         if !ok {
//                 statusCode = http.StatusInternalServerError
//         }

//         errRsp := newErrorResponse(err.Error())

//         ctx.JSON(statusCode, errRsp)
// }

// handleAbort sends an error response and aborts the request with the specified status code and error message

// func handleAbort(ctx *gin.Context, err error) {
//         statusCode, ok := errorStatusMap[err]
//         if !ok {
//                 statusCode = http.StatusInternalServerError
//         }

//         rsp := newErrorResponse(err.Error())
//         ctx.AbortWithStatusJSON(statusCode, rsp)
// }

// handleSuccess sends a success response with the specified status code and optional data
func handleSuccess(ctx *gin.Context, data any) <span class="cov8" title="1">{
        // rsp := newResponse(true, "Success", data)
        ctx.JSON(http.StatusOK, data)
}</span>

func handleCreateSuccess(ctx *gin.Context, data any) <span class="cov8" title="1">{
        // rsp := newResponse(true, "Success", data)
        ctx.JSON(http.StatusCreated, data)
}</span>

/*
func handleError(ctx *gin.Context, message string) {
        rsp := newResponse(false, message, nil)
        ctx.JSON(http.StatusInternalServerError, rsp)
}
        */

// type SMSReportResponse struct {
//         SerialNo        uint64  `json:"serialno"`
//         Date            string  `json:"date"`
//         Time            string  `json:"time"`
//         CommunicationID *string `json:"commid"`
//         ApplicationID   *string `json:"applicationid"`
//         FacilityID      *string `json:"facilityid"`
//         MessageType     *int64  `json:"messagetype"`
//         MessageText     *string `json:"messagetext"`
//         MobileNumber    *int64  `json:"mobilenumber"`
//         GatewayID       *string `json:"gatewayid"`
//         Status          string  `json:"status"`
// }

/*
type SMSReportResponse2 struct {
        SerialNo        uint64  `json:"serial_no"`
        Date            string  `json:"date"`
        Time            string  `json:"time"`
        CommunicationID *string `json:"comm_id"`
        ApplicationID   *string `json:"application_id"`
        FacilityID      *string `json:"facility_id"`
        MessagePriority *int64  `json:"message_priority"`
        MessageText     *string `json:"message_text"`
        MobileNumber    *int64  `json:"mobile_number"`
        GatewayID       *string `json:"gateway_id"`
        Status          string  `json:"status"`
}

func NewSMSReportResponse(sr []domain.SMSReport) []SMSReportResponse2 {
        rsp := make([]SMSReportResponse2, len(sr))
        for i, value := range sr {
                date := value.CreatedDate.Format("02-01-2006")
                time := value.CreatedDate.Format("15:04:05")
                var status string
                if value.Status == "submitted" {
                        status = "Success"
                } else {
                        status = "Failed"
                }
                rsp[i] = SMSReportResponse2{
                        SerialNo:        value.SerialNo,
                        Date:            date,
                        Time:            time,
                        CommunicationID: value.CommunicationID,
                        ApplicationID:   value.ApplicationID,
                        FacilityID:      value.FacilityID,
                        MessagePriority: value.MessagePriority,
                        MessageText:     value.MessageText,
                        MobileNumber:    value.MobileNumber,
                        GatewayID:       value.GatewayID,
                        Status:          status,
                }
        }
        return rsp
}

type SMSAggregateReportResponse struct {
        SerialNo        uint64 `json:"serial_no"`
        ApplicationName string `json:"application_name"`
        TemplateName    string `json:"template_name"`
        ProviderName    string `json:"provider_name"`
        Date            string `json:"date"`
        TotalSMS        int64  `json:"total_sms"`
        Success         int64  `json:"success"`
        Failed          int64  `json:"failed"`
        SuccessPercent  string `json:"success_percent"`
        FailurePercent  string `json:"failure_percent"`
}

func NewSMSAggregateReportResponse(sr []domain.SMSAggregateReport, reportType int8) []SMSAggregateReportResponse {
        rsp := make([]SMSAggregateReportResponse, len(sr))
        for i, value := range sr {
                date := value.CreatedDate.Format("02-01-2006")
                Spercent := float64(value.Success) * 100 / float64(value.TotalSMS)
                Fpercent := float64(value.Failed) * 100 / float64(value.TotalSMS)
                rsp[i] = SMSAggregateReportResponse{
                        SerialNo:       value.SerialNo,
                        Date:           date,
                        TotalSMS:       value.TotalSMS,
                        Success:        value.Success,
                        Failed:         value.Failed,
                        SuccessPercent: fmt.Sprintf("%.2f", Spercent),
                        FailurePercent: fmt.Sprintf("%.2f", Fpercent),
                }
                switch reportType {
                case 1:
                        rsp[i].ApplicationName = value.ApplicationName
                case 2:
                        rsp[i].TemplateName = value.TemplateName
                case 3:
                        rsp[i].ProviderName = value.ProviderName
                }
        }
        return rsp
}
*/
</pre>
		
		<pre class="file" id="file8" style="display: none">package response

import (
        "MgApplication/core/domain"
        "MgApplication/core/port"
        "time"
)

type createMsgApplicationResponse struct {
        ApplicationID   uint64    `json:"application_id" db:"application_id"`
        ApplicationName string    `json:"application_name" db:"application_name"`
        RequestType     string    `json:"request_type" db:"request_type"`
        SecretKey       string    `json:"secret_key" db:"secret_key"`
        CreatedDate     time.Time `json:"created_date" db:"created_date"`
        UpdatedDate     time.Time `json:"updated_date" db:"updated_date"`
        Status          int       `json:"status" db:"status_cd"`
}

func NewCreateMsgApplicationResponse(appln *domain.MsgApplications) *createMsgApplicationResponse <span class="cov8" title="1">{
        response := createMsgApplicationResponse{
                ApplicationID:   appln.ApplicationID,
                ApplicationName: appln.ApplicationName,
                RequestType:     appln.RequestType,
                SecretKey:       appln.SecretKey,
                CreatedDate:     appln.CreatedDate,
                UpdatedDate:     appln.UpdatedDate,
                Status:          appln.Status,
        }
        return &amp;response
}</span>

type CreateMsgApplicationAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        Data                 *createMsgApplicationResponse `json:"data"`
}

type listMsgApplicationsResponse struct {
        ApplicationID   uint64 `json:"application_id" db:"application_id"`
        ApplicationName string `json:"application_name" db:"application_name"`
        RequestType     string `json:"request_type" db:"request_type"`
        Status          int    `json:"status" db:"status_cd"`
}

func NewListMsgApplicationsResponse(applications []domain.MsgApplicationsGet) []listMsgApplicationsResponse <span class="cov8" title="1">{
        var response []listMsgApplicationsResponse
        for _, application := range applications </span><span class="cov8" title="1">{
                applicationResponse := listMsgApplicationsResponse{
                        ApplicationID:   application.ApplicationID,
                        ApplicationName: application.ApplicationName,
                        RequestType:     application.RequestType,
                        Status:          application.Status,
                }
                response = append(response, applicationResponse)

        }</span>
        <span class="cov8" title="1">return response</span>
}

type ListMsgApplicationsAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        port.MetaDataResponse     `json:",inline"`
        Data                 []listMsgApplicationsResponse `json:"data"`
}

type fetchMsgApplicationResponse struct {
        ApplicationID   uint64 `json:"application_id" db:"application_id"`
        ApplicationName string `json:"application_name" db:"application_name"`
        RequestType     string `json:"request_type" db:"request_type"`
        Status          int    `json:"status" db:"status_cd"`
}

func NewFetchMsgApplicationResponse(applications []domain.MsgApplicationsGet) []fetchMsgApplicationResponse <span class="cov8" title="1">{
        var response []fetchMsgApplicationResponse
        for _, application := range applications </span><span class="cov8" title="1">{
                applicationResponse := fetchMsgApplicationResponse{
                        ApplicationID:   application.ApplicationID,
                        ApplicationName: application.ApplicationName,
                        RequestType:     application.RequestType,
                        Status:          application.Status,
                }
                response = append(response, applicationResponse)

        }</span>
        <span class="cov8" title="1">return response</span>
}

type FetchMsgApplicationAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        port.MetaDataResponse     `json:",inline"`
        Data                 []fetchMsgApplicationResponse `json:"data"`
}

/*
type fetchActiveMsgApplicationResponse struct {
        ApplicationID   uint64 `json:"application_id" db:"application_id"`
        ApplicationName string `json:"application_name" db:"application_name"`
        RequestType     string `json:"request_type" db:"request_type"`
        Status          int    `json:"status" db:"status_cd"`
}

func NewFetchActiveMsgApplicationResponse(applications []domain.MsgApplicationsGet) []fetchActiveMsgApplicationResponse {
        var response []fetchActiveMsgApplicationResponse
        for _, application := range applications {
                applicationResponse := fetchActiveMsgApplicationResponse{
                        ApplicationID:   application.ApplicationID,
                        ApplicationName: application.ApplicationName,
                        RequestType:     application.RequestType,
                        Status:          application.Status,
                }
                response = append(response, applicationResponse)

        }
        return response
}

type FetchActiveMsgApplicationAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        port.MetaDataResponse     `json:",inline"`
        Data                 []fetchActiveMsgApplicationResponse `json:"data"`
}
        */

type updateMsgApplicationResponse struct {
        ApplicationID   uint64    `json:"application_id" db:"application_id"`
        ApplicationName string    `json:"application_name" db:"application_name"`
        RequestType     string    `json:"request_type" db:"request_type"`
        UpdatedDate     time.Time `json:"updated_date" db:"updated_date"`
        Status          int       `json:"status" db:"status_cd"`
}

func NewUpdateMsgApplicationResponse(appln *domain.EditApplication) *updateMsgApplicationResponse <span class="cov8" title="1">{
        response := updateMsgApplicationResponse{
                ApplicationID:   appln.ApplicationID,
                ApplicationName: appln.ApplicationName,
                RequestType:     appln.RequestType,
                UpdatedDate:     appln.UpdatedDate,
                Status:          appln.Status,
        }
        return &amp;response
}</span>

type UpdateMsgApplicationAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        Data                 *updateMsgApplicationResponse `json:"data"`
}

// func FetchApplicationStatus(interface{}) {

// }

type ToggleAppStatusAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        Data                 interface{} `json:"data"`
}

/*
type getMsgApplicationResponse struct {
        ApplicationID   uint64 `json:"application_id" db:"application_id"`
        ApplicationName string `json:"application_name" db:"application_name"`
        RequestType     string `json:"request_type" db:"request_type"`
        Status          int    `json:"status" db:"status_cd"`
}

func NewGetMsgApplicationResponse(applications []domain.MsgApplicationsGet) []getMsgApplicationResponse {
        var response []getMsgApplicationResponse
        for _, application := range applications {
                applicationResponse := getMsgApplicationResponse{
                        ApplicationID:   application.ApplicationID,
                        ApplicationName: application.ApplicationName,
                        RequestType:     application.RequestType,
                        Status:          application.Status,
                }
                response = append(response, applicationResponse)

        }
        return response
}

type GetMsgApplicationAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        port.MetaDataResponse          `json:",inline"`
        Data                      []getMsgApplicationResponse `json:"data"`
}
*/</pre>
		
		<pre class="file" id="file9" style="display: none">package response

import (
        "MgApplication/core/domain"
        "MgApplication/core/port"
        "encoding/xml"
)

type bulkSMSInitiateResponse struct {
        MsgResponse string
        ReferenceID string
}

func NewBulkSMSInitiateResponse(rsp string, referenceId string) bulkSMSInitiateResponse <span class="cov0" title="0">{
        response := bulkSMSInitiateResponse{
                MsgResponse: rsp,
                ReferenceID: referenceId,
        }
        return response

}</span>

type BulkSMSInitiateAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        Data                      bulkSMSInitiateResponse `json:"data"`
}

type ValidateBulkSMSOTPAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        Data                      bool `json:"data"`
}

/*
type transformedDataRsp struct {
        MobileNumber string `json:"mobile_number"`
        Message      string `json:"message"`
}

type buildTargetFileResponse struct {
        Rows     []transformedDataRsp `json:"rows"`
        UniqueID string               `json:"unique_id"`
}

func NewBuildTargetFileResponse(transRows []domain.TransformedData, uniqueID string) buildTargetFileResponse {
        var transformedRows []transformedDataRsp
        for _, row := range transRows {
                transformedRow := transformedDataRsp{
                        MobileNumber: row.MobileNumber,
                        Message:      row.Message,
                }
                transformedRows = append(transformedRows, transformedRow)
        }

        response := buildTargetFileResponse{
                Rows:     transformedRows,
                UniqueID: uniqueID,
        }
        return response
}

type BuildTargetFileAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`        // Common metadata like status code and message
        Data                      buildTargetFileResponse `json:"data"` // Embedded BuildTargetFileRsp struct
}
*/

type sendBulkSMSResponse struct {
        Timestamp string `json:"timestamp"`
        RequestID string `json:"request_id"`
        Code      string `json:"code"`
        Info      string `json:"info"`
}

// func NewSendBulkSMSResponseOld(bulk *domain.NicResponse) *sendBulkSMSResponse {
//         response := sendBulkSMSResponse{
//                 Timestamp: bulk.Timestamp,
//                 RequestID: bulk.RequestID,
//                 Code:      bulk.Code,
//                 Info:      bulk.Info,
//         }
//         return &amp;response

// }

type NicXmlResponse struct {
        XMLName   xml.Name `xml:"a2wml"`
        Version   string   `xml:"response&gt;version"`
        Timestamp string   `xml:"response&gt;timestamp"`
        RequestID string   `xml:"response&gt;request ID"`
        Code      string   `xml:"response&gt;code"`
        Info      string   `xml:"response&gt;info"`
}

func NewSendBulkSMSResponse(bulk *domain.NicResponseXml) *sendBulkSMSResponse <span class="cov0" title="0">{
        response := sendBulkSMSResponse{
                Timestamp: bulk.Timestamp,
                RequestID: bulk.RequestID,
                Code:      bulk.Code,
                Info:      bulk.Info,
        }
        return &amp;response

}</span>

type SendBulkSMSAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        Data                      *sendBulkSMSResponse `json:"data"`
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package response

import (
        "MgApplication/core/domain"
        "MgApplication/core/port"
)

type createSMSResponse struct {
        CommunicationID  string `json:"communication_id"`
        CompleteResponse string `json:"complete_response"`
        ReferenceID      string `jsong:"reference_id"`
        ResponseCode     string `json:"status"`
        ResponseText     string `json:"response_text"`
}

func NewCreateSMSResponse(msg *domain.MsgResponse) *createSMSResponse <span class="cov8" title="1">{
        response := createSMSResponse{
                CommunicationID:  msg.CommunicationID,
                CompleteResponse: msg.CompleteResponse,
                ReferenceID:      msg.ReferenceID,
                ResponseCode:     msg.ResponseCode,
                ResponseText:     msg.ResponseText,
        }
        return &amp;response
}</span>

type CreateSMSAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        Data                      *createSMSResponse `json:"data"`
}

type TestSMSAPIResponse struct {
        //port.StatusCodeAndMessage `json:",inline"`
        Data map[string]interface{} `json:"data"`
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package response

import (
        "MgApplication/core/domain"
        "MgApplication/core/port"
        "encoding/json"
)

type createSMSProviderResponse struct {
        ProviderID        uint64          `json:"provider_id" db:"provider_id"`
        ProviderName      string          `json:"provider_name" db:"provider_name"`
        ShortName         string          `json:"short_name" db:"short_name"`
        Services          string          `json:"services" db:"services"`
        ConfigurationKeys json.RawMessage `json:"configuration_keys" db:"configuration_key"`
        //ConfigurationKeys interface{} `json:"configuration_keys" db:"configuration_key"`
        Status int `json:"status" db:"status_cd"`
}

func NewCreateSMSProviderResponse(provider *domain.MsgProvider) *createSMSProviderResponse <span class="cov8" title="1">{

        response := createSMSProviderResponse{
                ProviderID:        provider.ProviderID,
                ProviderName:      provider.ProviderName,
                ShortName:         provider.ShortName,
                Services:          provider.Services,
                ConfigurationKeys: provider.ConfigurationKeys,
                Status:            provider.Status,
        }
        return &amp;response
}</span>

type CreateSMSProviderAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        Data                      *createSMSProviderResponse `json:"data"`
}

type listSMSProvidersResponse struct {
        ProviderID        uint64          `json:"provider_id" db:"provider_id"`
        ProviderName      string          `json:"provider_name" db:"provider_name"`
        ShortName         string          `json:"short_name" db:"short_name"`
        Services          string          `json:"services" db:"services"`
        ConfigurationKeys json.RawMessage `json:"configuration_keys" db:"configuration_key"`
        //ConfigurationKeys interface{} `json:"configuration_keys" db:"configuration_key"`
        Status int `json:"status" db:"status_cd"`
}

func NewListSMSProvidersResponse(providers []domain.MsgProvider) []listSMSProvidersResponse <span class="cov8" title="1">{
        var response []listSMSProvidersResponse
        for _, provider := range providers </span><span class="cov8" title="1">{
                providerResponse := listSMSProvidersResponse{
                        ProviderID:        provider.ProviderID,
                        ProviderName:      provider.ProviderName,
                        ShortName:         provider.ShortName,
                        Services:          provider.Services,
                        ConfigurationKeys: provider.ConfigurationKeys,
                        Status:            provider.Status,
                }
                response = append(response, providerResponse)
        }</span>
        <span class="cov8" title="1">return response</span>
}

type ListSMSProvidersAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        port.MetaDataResponse          `json:",inline"`
        Data                      []listSMSProvidersResponse `json:"data"`
}

type fetchSMSProviderResponse struct {
        ProviderID        uint64          `json:"provider_id" db:"provider_id"`
        ProviderName      string          `json:"provider_name" db:"provider_name"`
        ShortName         string          `json:"short_name" db:"short_name"`
        Services          string          `json:"services" db:"services"`
        ConfigurationKeys json.RawMessage `json:"configuration_keys" db:"configuration_key"`
        //ConfigurationKeys interface{} `json:"configuration_keys" db:"configuration_key"`
        Status int `json:"status" db:"status_cd"`
}

func NewFetchSMSProviderResponse(providers []domain.MsgProvider) []fetchSMSProviderResponse <span class="cov8" title="1">{
        var response []fetchSMSProviderResponse
        for _, provider := range providers </span><span class="cov0" title="0">{
                providerResponse := fetchSMSProviderResponse{
                        ProviderID:        provider.ProviderID,
                        ProviderName:      provider.ProviderName,
                        ShortName:         provider.ShortName,
                        Services:          provider.Services,
                        ConfigurationKeys: provider.ConfigurationKeys,
                        Status:            provider.Status,
                }
                response = append(response, providerResponse)
        }</span>
        <span class="cov8" title="1">return response</span>
}

type FetchSMSProviderAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        port.MetaDataResponse          `json:",inline"`
        Data                      []fetchSMSProviderResponse `json:"data"`
}

/*
type fetchActiveSMSProviderResponse struct {
        ProviderID        uint64          `json:"provider_id" db:"provider_id"`
        ProviderName      string          `json:"provider_name" db:"provider_name"`
        ShortName         string          `json:"short_name" db:"short_name"`
        Services          string          `json:"services" db:"services"`
        ConfigurationKeys json.RawMessage `json:"configuration_keys" db:"configuration_key"`
        //ConfigurationKeys interface{} `json:"configuration_keys" db:"configuration_key"`
        Status int `json:"status" db:"status_cd"`
}

func NewFetchActiveSMSProviderResponse(providers []domain.MsgProvider) []fetchActiveSMSProviderResponse {
        var response []fetchActiveSMSProviderResponse
        for _, provider := range providers {
                providerResponse := fetchActiveSMSProviderResponse{
                        ProviderID:        provider.ProviderID,
                        ProviderName:      provider.ProviderName,
                        ShortName:         provider.ShortName,
                        Services:          provider.Services,
                        ConfigurationKeys: provider.ConfigurationKeys,
                        Status:            provider.Status,
                }
                response = append(response, providerResponse)

        }
        return response
}

type FetchActiveSMSProviderAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        port.MetaDataResponse          `json:",inline"`
        Data                      []fetchActiveSMSProviderResponse `json:"data"`
}
*/

type updateSMSProviderResponse struct {
        ProviderID        uint64          `json:"provider_id" db:"provider_id"`
        ProviderName      string          `json:"provider_name" db:"provider_name"`
        ShortName         string          `json:"short_name" db:"short_name"`
        Services          string          `json:"services" db:"services"`
        ConfigurationKeys json.RawMessage `json:"configuration_keys" db:"configuration_key"`
        //ConfigurationKeys interface{} `json:"configuration_keys" db:"configuration_key"`
        Status int `json:"status" db:"status_cd"`
}

func NewUpdateSMSProviderResponse(provider *domain.MsgProvider) *updateSMSProviderResponse <span class="cov8" title="1">{

        response := updateSMSProviderResponse{
                ProviderID:        provider.ProviderID,
                ProviderName:      provider.ProviderName,
                ShortName:         provider.ShortName,
                Services:          provider.Services,
                ConfigurationKeys: provider.ConfigurationKeys,
                Status:            provider.Status,
        }
        return &amp;response
}</span>

type UpdateSMSProviderAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        Data                      *updateSMSProviderResponse `json:"data"`
}

// func FetchProviderStatus(interface{}) {

// }

type ToggleProviderStatusAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        Data                      interface{} `json:"data"`
}

/*
type getSMSProvidersResponse struct {
        ProviderID        uint64          `json:"provider_id" db:"provider_id"`
        ProviderName      string          `json:"provider_name" db:"provider_name"`
        ShortName         string          `json:"short_name" db:"short_name"`
        Services          string          `json:"services" db:"services"`
        ConfigurationKeys json.RawMessage `json:"configuration_keys" db:"configuration_key"`
        //ConfigurationKeys interface{} `json:"configuration_keys" db:"configuration_key"`
        Status int `json:"status" db:"status_cd"`
}

func NewGetSMSProviderResponse(providers []domain.MsgProvider) []getSMSProvidersResponse {
        var response []getSMSProvidersResponse
        for _, provider := range providers {
                providerResponse := getSMSProvidersResponse{
                        ProviderID:        provider.ProviderID,
                        ProviderName:      provider.ProviderName,
                        ShortName:         provider.ShortName,
                        Services:          provider.Services,
                        ConfigurationKeys: provider.ConfigurationKeys,
                        Status:            provider.Status,
                }
                response = append(response, providerResponse)
        }
        return response
}

type GetSMSProvidersAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        port.MetaDataResponse     `json:",inline"`
        Data                 []getSMSProvidersResponse `json:"data"`
}
*/</pre>
		
		<pre class="file" id="file12" style="display: none">package response

import (
        "MgApplication/core/domain"
        "MgApplication/core/port"
        "time"
)

type smsDashboardResponse struct {
        TotalSMSSent       int64 `json:"total_sms_sent" db:"total_sms_sent"`
        TotalOTPMessages   int64 `json:"total_otp_messages" db:"total_otps"`
        TotalTransMessages int64 `json:"total_trans_messages" db:"total_transactions"`
        TotalBulkMessages  int64 `json:"total_bulk_messages" db:"total_bulk_sms"`
        TotalPromMessages  int64 `json:"total_prom_messages" db:"total_promotional_sms"`
        TotalTemplates     int64 `json:"total_templates" db:"total_templates"`
        TotalProviders     int64 `json:"total_providers" db:"total_providers"`
        TotalApplications  int64 `json:"total_applications" db:"total_applications"`
}

func NewSMSDashboardResponse(dashboard *domain.SMSDashboard) *smsDashboardResponse <span class="cov8" title="1">{
        response := smsDashboardResponse{
                TotalSMSSent:       dashboard.TotalSMSSent,
                TotalOTPMessages:   dashboard.TotalOTPMessages,
                TotalTransMessages: dashboard.TotalTransMessages,
                TotalBulkMessages:  dashboard.TotalBulkMessages,
                TotalPromMessages:  dashboard.TotalPromMessages,
                TotalTemplates:     dashboard.TotalTemplates,
                TotalProviders:     dashboard.TotalProviders,
                TotalApplications:  dashboard.TotalApplications,
        }
        return &amp;response
}</span>

type SMSDashboardAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        Data                      *smsDashboardResponse `json:"data"`
}

type smsSentStatusReportResponse struct {
        SerialNo        uint64    `json:"serial_no" db:"serial_number"`
        CreatedDate     time.Time `json:"created_date" db:"created_date"`
        CommunicationID *string   `json:"comm_id" db:"communication_id"`
        ApplicationID   *string   `json:"application_id" db:"application_id"`
        FacilityID      *string   `json:"facility_id" db:"facility_id"`
        MessagePriority *int64    `json:"message_priority" db:"priority"`
        MessageText     *string   `json:"message_text" db:"message_text"`
        MobileNumber    *int64    `json:"mobile_number" db:"mobile_number"`
        GatewayID       *string   `json:"gateway_id" db:"gateway"`
        Status          string    `json:"status" db:"status"`
}

func NewSMSSentStatusReportResponse(reports []domain.SMSReport) []smsSentStatusReportResponse <span class="cov8" title="1">{
        var response []smsSentStatusReportResponse
        for _, report := range reports </span><span class="cov8" title="1">{
                ReportResponse := smsSentStatusReportResponse{
                        SerialNo:        report.SerialNo,
                        CreatedDate:     report.CreatedDate,
                        CommunicationID: report.CommunicationID,
                        ApplicationID:   report.ApplicationID,
                        FacilityID:      report.FacilityID,
                        MessagePriority: report.MessagePriority,
                        MessageText:     report.MessageText,
                        MobileNumber:    report.MobileNumber,
                        GatewayID:       report.GatewayID,
                        Status:          report.Status,
                }
                response = append(response, ReportResponse)
        }</span>
        <span class="cov8" title="1">return response</span>
}

type SMSSentStatusReportAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        port.MetaDataResponse     `json:",inline"`
        Data                      []smsSentStatusReportResponse `json:"data"`
}

type aggregateSMSReportResponse struct {
        SerialNo        uint64    `json:"serial_no" db:"serial_number"`
        ApplicationName string    `json:"application_name" db:"application_name"`
        TemplateName    string    `json:"template_name" db:"template_name"`
        ProviderName    string    `json:"provider_name" db:"provider_name"`
        CreatedDate     time.Time `json:"created_date" db:"created_date"`
        TotalSMS        int64     `json:"total_sms" db:"total_sms"`
        Success         int64     `json:"success" db:"success"`
        Failed          int64     `json:"failed" db:"failed"`
}

func NewAggregateSMSReportResponse(reports []domain.SMSAggregateReport) []aggregateSMSReportResponse <span class="cov8" title="1">{
        var response []aggregateSMSReportResponse
        for _, report := range reports </span><span class="cov8" title="1">{
                ReportResponse := aggregateSMSReportResponse{
                        SerialNo:        report.SerialNo,
                        ApplicationName: report.ApplicationName,
                        TemplateName:    report.TemplateName,
                        ProviderName:    report.ProviderName,
                        CreatedDate:     report.CreatedDate,
                        TotalSMS:        report.TotalSMS,
                        Success:         report.Success,
                        Failed:          report.Failed,
                }
                response = append(response, ReportResponse)
        }</span>
        <span class="cov8" title="1">return response</span>
}

type AggregateSMSReportAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        port.MetaDataResponse     `json:",inline"`
        Data                      []aggregateSMSReportResponse `json:"data"`
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package response

import (
        "MgApplication/core/domain"
        "MgApplication/core/port"
)

type CreateTemplateAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        // Data                 *CreateSMSProviderResponse `json:"data"`
}

type listTemplatesResponse struct {
        TemplateLocalID uint64 `json:"template_local_id" db:"template_local_id"`
        ApplicationID   string `json:"application_id" db:"application_id"`
        TemplateName    string `json:"template_name" db:"template_name"`
        TemplateFormat  string `json:"template_format" db:"template_format"`
        SenderID        string `json:"sender_id" db:"sender_id"`
        EntityID        string `json:"entity_id" db:"entity_id"`
        TemplateID      string `json:"template_id" db:"template_id"`
        Gateway         string `json:"gateway" db:"gateway"`
        MessageType     string `json:"message_type" db:"message_type"`
        Status          int    `json:"status" db:"status_cd"`
}

func NewListTemplatesResponse(templates []domain.MaintainTemplate) []listTemplatesResponse <span class="cov8" title="1">{
        var response []listTemplatesResponse
        for _, template := range templates </span><span class="cov8" title="1">{
                templateResponse := listTemplatesResponse{
                        TemplateLocalID: template.TemplateLocalID,
                        ApplicationID:   template.ApplicationID,
                        TemplateName:    template.TemplateName,
                        TemplateFormat:  template.TemplateFormat,
                        SenderID:        template.SenderID,
                        EntityID:        template.EntityID,
                        TemplateID:      template.TemplateID,
                        Gateway:         template.Gateway,
                        MessageType:     template.MessageType,
                        Status:          template.Status,
                }
                response = append(response, templateResponse)
        }</span>
        <span class="cov8" title="1">return response</span>
}

type ListTemplatesAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        port.MetaDataResponse     `json:",inline"`
        Data                      []listTemplatesResponse `json:"data"`
}

type fetchTemplateResponse struct {
        TemplateLocalID uint64 `json:"template_local_id" db:"template_local_id"`
        ApplicationID   string `json:"application_id" db:"application_id"`
        TemplateName    string `json:"template_name" db:"template_name"`
        TemplateFormat  string `json:"template_format" db:"template_format"`
        SenderID        string `json:"sender_id" db:"sender_id"`
        EntityID        string `json:"entity_id" db:"entity_id"`
        TemplateID      string `json:"template_id" db:"template_id"`
        Gateway         string `json:"gateway" db:"gateway"`
        MessageType     string `json:"message_type" db:"message_type"`
        Status          int    `json:"status" db:"status_cd"`
        TotalCount      uint64
}

func NewFetchTemplateResponse(templates []domain.MaintainTemplate) []fetchTemplateResponse <span class="cov8" title="1">{
        var response []fetchTemplateResponse
        for _, template := range templates </span><span class="cov8" title="1">{
                templateResponse := fetchTemplateResponse{
                        TemplateLocalID: template.TemplateLocalID,
                        ApplicationID:   template.ApplicationID,
                        TemplateName:    template.TemplateName,
                        TemplateFormat: template.TemplateFormat,
                        SenderID:        template.SenderID,
                        EntityID:        template.EntityID,
                        TemplateID:      template.TemplateID,
                        Gateway:         template.Gateway,
                        MessageType:     template.MessageType,
                        Status:          template.Status,
                }
                response = append(response, templateResponse)
        }</span>
        <span class="cov8" title="1">return response</span>
}

type FetchTemplateAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        //MetaDataResponse     `json:",inline"`
        Data []fetchTemplateResponse `json:"data"`
}

type fetchTemplateNameResponse struct {
        TemplateLocalID uint64 `json:"template_local_id" db:"template_local_id"`
        TemplateName    string `json:"template_name" db:"template_name"`
}

func NewFetchTemplateNameResponse(templateNames []domain.GetTemplatebyAPPID) []fetchTemplateNameResponse <span class="cov8" title="1">{
        var response []fetchTemplateNameResponse
        for _, template := range templateNames </span><span class="cov8" title="1">{
                templateResponse := fetchTemplateNameResponse{
                        TemplateLocalID: template.TemplateLocalID,
                        TemplateName:    template.TemplateName,
                }
                response = append(response, templateResponse)
        }</span>
        <span class="cov8" title="1">return response</span>
}

type FetchTemplateNameAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        //MetaDataResponse     `json:",inline"`
        Data []fetchTemplateNameResponse `json:"data"`
}

type fetchTemplateDetailsResponse struct {
        TemplateLocalID uint64 `json:"template_local_id" db:"template_local_id"`
        TemplateName    string `json:"template_name" db:"template_name"`
        TemplateFormat  string `json:"template_format" db:"template_format"`
        TemplateID      string `json:"template_id" db:"template_id"`
        EntityID        string `json:"entity_id" db:"entity_id"`
        SenderID        string `json:"sender_id" db:"sender_id"`
        MessageType     string `json:"message_type" db:"message_type"`
}

func NewFetchTemplateDetailsResponse(templateDetails []domain.GetTemplateformatbyID) []fetchTemplateDetailsResponse <span class="cov8" title="1">{
        var response []fetchTemplateDetailsResponse
        for _, template := range templateDetails </span><span class="cov8" title="1">{
                templateResponse := fetchTemplateDetailsResponse{
                        TemplateLocalID: template.TemplateLocalID,
                        TemplateName:    template.TemplateName,
                        TemplateFormat:  template.TemplateFormat,
                        TemplateID:      template.TemplateID,
                        EntityID:        template.EntityID,
                        SenderID:        template.SenderID,
                        MessageType:     template.MessageType,
                }
                response = append(response, templateResponse)
        }</span>
        <span class="cov8" title="1">return response</span>
}

type FetchTemplateDetailsAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        //MetaDataResponse     `json:",inline"`
        Data []fetchTemplateDetailsResponse `json:"data"`
}

type ToggleTemplateStatusAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        Data                      interface{} `json:"data"`
}

// func EditTemplateResponse(provider *domain.MsgProvider) *EditTemplateResponse {

//         response := EditSMSProviderResponse{
//                 ProviderID:        provider.ProviderID,
//                 ProviderName:      provider.ProviderName,
//                 ShortName:         provider.ShortName,
//                 Services:          provider.Services,
//                 ConfigurationKeys: provider.ConfigurationKeys,
//                 Status:            provider.Status,
//         }
//         return &amp;response
// }

type UpdateTemplatesAPIResponse struct {
        port.StatusCodeAndMessage `json:",inline"`
        //Data                 *EditTemplateResponse `json:"data"`
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handler

import (
        "MgApplication/core/domain"
        "MgApplication/core/port"
        "MgApplication/handler/response"
        repo "MgApplication/repo/postgres"
        "math"

        // _ "time"

        "github.com/gin-gonic/gin"
        config "MgApplication/api-config"
        apierrors "MgApplication/api-errors"
        log "MgApplication/api-log"
        validation "MgApplication/api-validation"
)

// MgApplication Handler represents the HTTP handler for MgApplication related requests
type TemplateHandler struct {
        svc *repo.TemplateRepository
        c   *config.Config
}

// MgApplication Handler creates a new MgApplicatPion Handler instance
func NewTemplateHandler(svc *repo.TemplateRepository, c *config.Config) *TemplateHandler <span class="cov8" title="1">{
        return &amp;TemplateHandler{
                svc,
                c,
        }
}</span>

type createTemplateRequest struct {
        TemplateLocalID uint64 `json:"template_local_id"`
        ApplicationID   string `json:"application_id" validate:"required,numeric" example:"4"`
        TemplateName    string `json:"template_name" validate:"required" example:"Test Template"`
        TemplateFormat  string `json:"template_format" validate:"required" example:"Dear {#var#}, Greetings from India Post on the occasion of {#var#} - Indiapost"`
        SenderID        string `json:"sender_id" validate:"required" example:"INPOST"`
        EntityID        string `json:"entity_id" example:"1001051725995192803"`
        TemplateID      string `json:"template_id" validate:"required,numeric" example:"1007188452935484904"`
        Gateway         string `json:"gateway" validate:"required" example:"1"`
        Status          bool   `json:"status" validate:"required" example:"true"`
        MessageType     string `json:"message_type" validate:"required" example:"PM"`
}

// CreateTemplateHandler godoc
//
//        @Summary                Creates a new message template
//        @Description        Creates a new Message template for message applications
//        @Tags                        Templates
//        @ID                                CreateTemplateHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        createTemplateRequest        body                createTemplateRequest                                true        "Create new Message Template"
//        @Success                201                                                {object}        response.CreateTemplateAPIResponse        "Message Template is created"
//        @Failure                400                                                {object}        apierrors.APIErrorResponse                        "Bad Request"
//        @Failure                401                                                {object}        apierrors.APIErrorResponse                        "Unauthorized"
//        @Failure                403                                                {object}        apierrors.APIErrorResponse                        "Forbidden"
//        @Failure                404                                                {object}        apierrors.APIErrorResponse                        "Data not found"
//        @Failure                409                                                {object}        apierrors.APIErrorResponse                        "Data conflict errpr"
//        @Failure                422                                                {object}        apierrors.APIErrorResponse                        "Binding or Validation error"
//        @Failure                500                                                {object}        apierrors.APIErrorResponse                        "Internal server error"
//        @Failure                502                                                {object}        apierrors.APIErrorResponse                        "Bad Gateway"
//        @Failure                504                                                {object}        apierrors.APIErrorResponse                        "Gateway Timeout"
//        @Router                        /sms-templates [post]
func (ch *TemplateHandler) CreateTemplateHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req createTemplateRequest

        if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for createTemplateRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for createTemplateRequest: %s", err.Error())
                return
        }</span>

        <span class="cov0" title="0">var aStatus int
        if req.Status </span><span class="cov0" title="0">{
                aStatus = 1
        }</span> else<span class="cov0" title="0"> {
                aStatus = 0
        }</span>

        <span class="cov0" title="0">maintaintemplate := domain.MaintainTemplate{
                ApplicationID:  req.ApplicationID,
                TemplateName:   req.TemplateName,
                TemplateFormat: req.TemplateFormat,
                SenderID:       req.SenderID,
                EntityID:       req.EntityID,
                TemplateID:     req.TemplateID,
                Gateway:        req.Gateway,
                MessageType:    req.MessageType,
                Status:         aStatus,
        }

        err := ch.svc.CreateTemplateRepo(ctx, &amp;maintaintemplate)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in CreateTemplateRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov0" title="0">apiRsp := response.CreateTemplateAPIResponse{
                StatusCodeAndMessage: port.CreateSuccess,
                // Data:                 rsp,
        }

        log.Debug(ctx, "CreateTemplateHandler response: %v", apiRsp)
        handleCreateSuccess(ctx, apiRsp)</span>
}

type listTemplatesRequest struct {
        port.MetaDataRequest
}

// ListTemplates godoc
//
//        @Summary                Get all Message Templates
//        @Description        Lists all message templates
//        @Tags                        Templates
//        @ID                                ListTemplatesHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        listTemplatesRequest        query                listTemplatesRequest                                true        "Fetch Templates"
//        @Success                200                                                {object}        response.ListTemplatesAPIResponse        "All Message Templates are retrieved"
//        @Failure                400                                                {object}        apierrors.APIErrorResponse                        "Bad Request"
//        @Failure                401                                                {object}        apierrors.APIErrorResponse                        "Unauthorized"
//        @Failure                403                                                {object}        apierrors.APIErrorResponse                        "Forbidden"
//        @Failure                404                                                {object}        apierrors.APIErrorResponse                        "Data not found"
//        @Failure                409                                                {object}        apierrors.APIErrorResponse                        "Data conflict errpr"
//        @Failure                422                                                {object}        apierrors.APIErrorResponse                        "Binding or Validation error"
//        @Failure                500                                                {object}        apierrors.APIErrorResponse                        "Internal server error"
//        @Failure                502                                                {object}        apierrors.APIErrorResponse                        "Bad Gateway"
//        @Failure                504                                                {object}        apierrors.APIErrorResponse                        "Gateway Timeout"
//        @Router                        /sms-templates [get]
func (ch *TemplateHandler) ListTemplatesHandler(ctx *gin.Context) <span class="cov8" title="1">{
        var req listTemplatesRequest

        if err := ctx.ShouldBindQuery(&amp;req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for ListTemplatesRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for ListTemplatesRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if req.Limit == 0 &amp;&amp; req.Skip == 0 </span><span class="cov8" title="1">{
                req.Limit = math.MaxInt32
        }</span>

        <span class="cov8" title="1">listTemplate := domain.Meta{
                Skip:  req.Skip,
                Limit: req.Limit,
        }

        templates, totalCount, err := ch.svc.ListTemplatesRepo(ctx, &amp;listTemplate)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in ListTemplatesRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">rsp := response.NewListTemplatesResponse(templates)
        metadata := port.NewMetaDataResponse(req.Skip, req.Limit, int(totalCount))
        apiRsp := response.ListTemplatesAPIResponse{
                StatusCodeAndMessage: port.ListSuccess,
                MetaDataResponse:     metadata,
                Data:                 rsp,
        }

        log.Debug(ctx, "ListTemplatesHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}

type toggleTemplateStatusRequest struct {
        TemplateLocalID uint64 `uri:"template-local-id" validate:"required,numeric" example:"355"`
}

// ToggleTemplateStatus godoc
//
//        @Summary                Modifies the status of Message Template
//        @Description        Modifies the status of Message Template
//        @Tags                        Templates
//        @ID                                ToggleTemplateStatusHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        toggleTemplateStatusRequest        path                toggleTemplateStatusRequest                                        true        "Message Template Status Request"
//        @Success                200                                                        {object}        response.ToggleTemplateStatusAPIResponse        "Message Template status is modified"
//        @Failure                400                                                        {object}        apierrors.APIErrorResponse                                        "Bad Request"
//        @Failure                401                                                        {object}        apierrors.APIErrorResponse                                        "Unauthorized"
//        @Failure                403                                                        {object}        apierrors.APIErrorResponse                                        "Forbidden"
//        @Failure                404                                                        {object}        apierrors.APIErrorResponse                                        "Data not found"
//        @Failure                409                                                        {object}        apierrors.APIErrorResponse                                        "Data conflict errpr"
//        @Failure                422                                                        {object}        apierrors.APIErrorResponse                                        "Binding or Validation error"
//        @Failure                500                                                        {object}        apierrors.APIErrorResponse                                        "Internal server error"
//        @Failure                502                                                        {object}        apierrors.APIErrorResponse                                        "Bad Gateway"
//        @Failure                504                                                        {object}        apierrors.APIErrorResponse                                        "Gateway Timeout"
//        @Router                        /sms-templates/{template-local-id}/status [put]
func (ch *TemplateHandler) ToggleTemplateStatusHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req toggleTemplateStatusRequest

        if err := ctx.ShouldBindUri(&amp;req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for toggleTemplateStatusRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for toggleTemplateStatusRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">msgtemplatereq := domain.StatusTemplate{
                TemplateLocalID: req.TemplateLocalID,
        }

        rsp, err := ch.svc.ToggleTemplateStatusRepo(ctx, &amp;msgtemplatereq)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in StatusTemplateRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">apiRsp := response.ToggleTemplateStatusAPIResponse{
                StatusCodeAndMessage: port.UpdateSuccess,
                //MetaDataResponse:     metadata,
                Data: rsp,
        }

        log.Debug(ctx, "ToggleTemplateStatusHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}

type fetchTemplateRequest struct {
        TemplateLocalID uint64 `uri:"template-local-id" validate:"required" example:"355"`
}

// FetchTemplate godoc
//
//        @Summary                Get Message Template by TemplateLocalID
//        @Description        Fetches Message Template by TemplateLocalID
//        @Tags                        Templates
//        @ID                                FetchTemplateHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        fetchTemplateRequest        path                fetchTemplateRequest                                true        "Get Message Template Request"
//        @Success                200                                                {object}        response.FetchTemplateAPIResponse        "Message Template is retrieved by TemplateLocalID"
//        @Failure                400                                                {object}        apierrors.APIErrorResponse                        "Bad Request"
//        @Failure                401                                                {object}        apierrors.APIErrorResponse                        "Unauthorized"
//        @Failure                403                                                {object}        apierrors.APIErrorResponse                        "Forbidden"
//        @Failure                404                                                {object}        apierrors.APIErrorResponse                        "Data not found"
//        @Failure                409                                                {object}        apierrors.APIErrorResponse                        "Data conflict errpr"
//        @Failure                422                                                {object}        apierrors.APIErrorResponse                        "Binding or Validation error"
//        @Failure                500                                                {object}        apierrors.APIErrorResponse                        "Internal server error"
//        @Failure                502                                                {object}        apierrors.APIErrorResponse                        "Bad Gateway"
//        @Failure                504                                                {object}        apierrors.APIErrorResponse                        "Gateway Timeout"
//        @Router                        /sms-templates/{template-local-id} [get]
func (ch *TemplateHandler) FetchTemplateHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req fetchTemplateRequest

        if err := ctx.ShouldBindUri(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for fetchTemplateRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for fetchTemplateRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">msgtemplatereq := domain.MaintainTemplate{
                TemplateLocalID: req.TemplateLocalID,
        }

        template, err := ch.svc.FetchTemplateRepo(ctx, &amp;msgtemplatereq)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in GetTemplatebyIDRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">rsp := response.NewFetchTemplateResponse(template)
        apiRsp := response.FetchTemplateAPIResponse{
                StatusCodeAndMessage: port.FetchSuccess,
                //MetaDataResponse:     metadata,
                Data: rsp,
        }

        log.Debug(ctx, "FetchTemplateHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}

type updateTemplateRequest struct {
        TemplateLocalID uint64 `uri:"template-local-id" validate:"required" example:"355" json:"-"`
        ApplicationID   string `json:"application_id" validate:"required" example:"4"`
        TemplateName    string `json:"template_name" validate:"required" example:"Std. Instruction CANCELLATION"`
        TemplateFormat  string `json:"template_format" validate:"required" example:"Standing Instruction {#var#} on Account No {#var#} was cancelled."`
        SenderID        string `json:"sender_id" validate:"required" example:"INPOST"`
        EntityID        string `json:"entity_id"`
        TemplateID      string `json:"template_id" validate:"required" example:"1007002656392643880"`
        Gateway         string `json:"gateway" validate:"required" example:"1"`
        MessageType     string `json:"message_type" validate:"required" example:"PM"`
        Status          bool   `json:"status" validate:"required" example:"true"`
}

// UpdateTemplate godoc
//
//        @Summary                Edits an existing Message Template
//        @Description        Allows editing of an existing Message Template
//        @Tags                        Templates
//        @ID                                UpdateTemplateHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        template-local-id                path                uint64                                                                true        "Edit Message Template Request"
//        @Param                        updateTemplateRequest        body                updateTemplateRequest                                true        "Edit Message Template Request"
//        @Success                200                                                {object}        response.UpdateTemplatesAPIResponse        "Message Template is modified"
//        @Failure                400                                                {object}        apierrors.APIErrorResponse                        "Bad Request"
//        @Failure                401                                                {object}        apierrors.APIErrorResponse                        "Unauthorized"
//        @Failure                403                                                {object}        apierrors.APIErrorResponse                        "Forbidden"
//        @Failure                404                                                {object}        apierrors.APIErrorResponse                        "Data not found"
//        @Failure                409                                                {object}        apierrors.APIErrorResponse                        "Data conflict errpr"
//        @Failure                422                                                {object}        apierrors.APIErrorResponse                        "Binding or Validation error"
//        @Failure                500                                                {object}        apierrors.APIErrorResponse                        "Internal server error"
//        @Failure                502                                                {object}        apierrors.APIErrorResponse                        "Bad Gateway"
//        @Failure                504                                                {object}        apierrors.APIErrorResponse                        "Gateway Timeout"
//        @Router                        /sms-templates/{template-local-id} [put]
func (ch *TemplateHandler) UpdateTemplateHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req updateTemplateRequest

        if err := ctx.ShouldBindUri(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "URI Binding failed for updateTemplateRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := ctx.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "JSON Binding failed for updateTemplateRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for updateTemplateRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">var aStatus int
        if req.Status </span><span class="cov8" title="1">{
                aStatus = 1
        }</span> else<span class="cov0" title="0"> {
                aStatus = 0
        }</span>

        <span class="cov8" title="1">msgtemplatereq := domain.MaintainTemplate{
                TemplateLocalID: req.TemplateLocalID,
                ApplicationID:   req.ApplicationID,
                TemplateName:    req.TemplateName,
                TemplateFormat:  req.TemplateFormat,
                SenderID:        req.SenderID,
                EntityID:        req.EntityID,
                TemplateID:      req.TemplateID,
                Gateway:         req.Gateway,
                MessageType:     req.MessageType,
                Status:          aStatus,
        }

        err := ch.svc.UpdateTemplateRepo(ctx, &amp;msgtemplatereq)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in EditTemplateRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">apiRsp := response.UpdateTemplatesAPIResponse{
                StatusCodeAndMessage: port.UpdateSuccess,
                //Data:                 rsp,
        }

        log.Debug(ctx, "UpdateTemplateHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}

type fetchTemplateByApplicationRequest struct {
        ApplicationID string `form:"application-id" validate:"required,numeric" example:"4"`
}

// FetchTemplateByApplication godoc
//
//        @Summary                Get Message Template names by ApplicationID
//        @Description        Fetches Message Template names by ApplicationID
//        @Tags                        Templates
//        @ID                                FetchTemplateByApplicationHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        fetchTemplateByApplicationRequest        query                fetchTemplateByApplicationRequest                true        "Get Message Template names Request"
//        @Success                200                                                                        {object}        response.FetchTemplateNameAPIResponse        "Message Template names are retrieved by ApplicationID"
//        @Failure                400                                                                        {object}        apierrors.APIErrorResponse                                "Bad Request"
//        @Failure                401                                                                        {object}        apierrors.APIErrorResponse                                "Unauthorized"
//        @Failure                403                                                                        {object}        apierrors.APIErrorResponse                                "Forbidden"
//        @Failure                404                                                                        {object}        apierrors.APIErrorResponse                                "Data not found"
//        @Failure                409                                                                        {object}        apierrors.APIErrorResponse                                "Data conflict errpr"
//        @Failure                422                                                                        {object}        apierrors.APIErrorResponse                                "Binding or Validation error"
//        @Failure                500                                                                        {object}        apierrors.APIErrorResponse                                "Internal server error"
//        @Failure                502                                                                        {object}        apierrors.APIErrorResponse                                "Bad Gateway"
//        @Failure                504                                                                        {object}        apierrors.APIErrorResponse                                "Gateway Timeout"
//        @Router                        /sms-templates/name [get]
func (ch *TemplateHandler) FetchTemplateByApplicationHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req fetchTemplateByApplicationRequest

        if err := ctx.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for fetchTemplateByApplicationRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov8" title="1">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for fetchTemplateByApplicationRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">msgtemplatereq := domain.MaintainTemplate{
                ApplicationID: req.ApplicationID,
        }

        template, err := ch.svc.FetchTemplateByApplicationRepo(ctx, &amp;msgtemplatereq)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in GetTemplatenamesbyIDRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">rsp := response.NewFetchTemplateNameResponse(template)
        apiRsp := response.FetchTemplateNameAPIResponse{
                StatusCodeAndMessage: port.FetchSuccess,
                //MetaDataResponse:     metadata,
                Data: rsp,
        }

        log.Debug(ctx, "FetchTemplateByApplicationHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}

type fetchTemplateDetailsRequest struct {
        TemplateLocalID uint64 `form:"template-local-id" example:"355"`
        ApplicationID   string `form:"application-id"  example:"4"`
        Templateformat  string `form:"template-format" example:"Dear {#var#}, your {#var#} is scheduled on {#var#}. Pl check details over {#var#} - INDPOST"`
}

// FetchTemplateDetails godoc
//
//        @Summary                Get Template Details
//        @Description        Fetch template details based on the provided query parameters such as TemplateLocalID, ApplicationID, and Templateformat.
//        @Tags                        Templates
//        @ID                                FetchTemplateDetailsHandler
//        @Accept                        json
//        @Produce                json
//        @Param                        fetchTemplateDetailsRequest        query                fetchTemplateDetailsRequest                                        false        "Query Parameters"
//        @Success                200                                                        {object}        response.FetchTemplateDetailsAPIResponse        "Fetched successfully"
//        @Failure                400                                                        {object}        apierrors.APIErrorResponse                                        "Bad Request"
//        @Failure                401                                                        {object}        apierrors.APIErrorResponse                                        "Unauthorized"
//        @Failure                403                                                        {object}        apierrors.APIErrorResponse                                        "Forbidden"
//        @Failure                404                                                        {object}        apierrors.APIErrorResponse                                        "Data not found"
//        @Failure                409                                                        {object}        apierrors.APIErrorResponse                                        "Data conflict errpr"
//        @Failure                422                                                        {object}        apierrors.APIErrorResponse                                        "Binding or Validation error"
//        @Failure                500                                                        {object}        apierrors.APIErrorResponse                                        "Internal server error"
//        @Failure                502                                                        {object}        apierrors.APIErrorResponse                                        "Bad Gateway"
//        @Failure                504                                                        {object}        apierrors.APIErrorResponse                                        "Gateway Timeout"
//        @Router                        /sms-templates/details [get]
func (ch *TemplateHandler) FetchTemplateDetailsHandler(ctx *gin.Context) <span class="cov8" title="1">{

        var req fetchTemplateDetailsRequest
        if err := ctx.ShouldBindQuery(&amp;req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleBindingError(ctx, err)
                log.Error(ctx, "Binding failed for fetchTemplateDetailsRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if err := validation.ValidateStruct(req); err != nil </span><span class="cov0" title="0">{
                apierrors.HandleValidationError(ctx, err)
                log.Error(ctx, "Validation failed for fetchTemplateDetailsRequest: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">if req.TemplateLocalID == 0 &amp;&amp; req.ApplicationID == "" &amp;&amp; req.Templateformat == "" </span><span class="cov8" title="1">{
                apierrors.HandleWithMessage(ctx, "at least one query param must be provided")
                log.Warn(ctx, "at least one query param must be provided")
                return
        }</span>

        <span class="cov8" title="1">msgtemplatereq := domain.MaintainTemplate{
                TemplateLocalID: req.TemplateLocalID,
                ApplicationID:   req.ApplicationID,
                TemplateFormat:  req.Templateformat,
        }

        template, err := ch.svc.FetchTemplateDetailsRepo(ctx, &amp;msgtemplatereq)
        if err != nil </span><span class="cov0" title="0">{
                apierrors.HandleDBError(ctx, err)
                log.Error(ctx, "Error in GetTemplateDetailsRepo function: %s", err.Error())
                return
        }</span>

        <span class="cov8" title="1">rsp := response.NewFetchTemplateDetailsResponse(template)
        apiRsp := response.FetchTemplateDetailsAPIResponse{
                StatusCodeAndMessage: port.FetchSuccess,
                //MetaDataResponse:     metadata,
                Data: rsp,
        }

        log.Debug(ctx, "FetchTemplateDetailsHandler response: %v", apiRsp)
        handleSuccess(ctx, apiRsp)</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package handler

import (
        "regexp"

        "github.com/go-playground/validator/v10"
        validation "MgApplication/api-validation"
)

func ServiceRequestType(f1 validator.FieldLevel) bool <span class="cov8" title="1">{
        // Define the regex pattern for a comma-separated list of numbers between 1 and 4
        requestTypePattern := "^[1-4](,[1-4])*$"
        re := regexp.MustCompile(requestTypePattern)
        return re.MatchString(f1.Field().String())
}</span>

func NewValidatorService() error <span class="cov8" title="1">{

        err := validation.Create()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // add the custom validator here
        // err = validation.RegisterCustomValidation("validateEmail", ValidateEmail, "Incorrect email Format")
        // if err != nil {
        //         return err
        // }

        // err = validation.RegisterCustomValidation("hourvalidate", HourValidate, "field %s must be in the format 'HH:MM:SS', with a valid hour (00-23), minute (00-59), and second (00-59), but received %v")
        // if err != nil {
        //         return err
        // }

        <span class="cov8" title="1">err = validation.RegisterCustomValidation("request_type", ServiceRequestType, "invalid values for %s, must be 1-4 but received %v")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = validation.RegisterCustomValidation("services", ServiceRequestType, "invalid values for %s, must be 1-4 but received %v")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// errorValidResponse represents a JSON response for validation errors.
// type errorValidResponse struct {
//         Success bool     `json:"success" example:"false"`
//         Message []string `json:"message" example:"Error message"`
//         Errorno []string `json:"errorno"`
// }

// // newErrorValidResponse creates a new error response body.
// func newErrorValidResponse(message []string, errorno []string) errorValidResponse {
//         return errorValidResponse{
//                 Success: false,
//                 Message: message,
//                 Errorno: errorno,
//         }
// }
</pre>
		
		<pre class="file" id="file16" style="display: none">package main

import (
        "MgApplication/bootstrap"
    "MgApplication/routes"
    bootstrapper "MgApplication/api-bootstrapper"

        "go.uber.org/fx"
)

// Swagger
//
//        @title                        Message Gateway API
//        @version                1.0
//        @description        A comprehensive API for managing addresses, offering endpoints for creation, update, deletion, and retrieval of Message Gateway data
//        @termsOfService        http://cept.gov.in/terms
//        @contact.name        API Support Team
//        @contact.url        http://cept.gov.in/support
//        @contact.email        support_cept@indiapost.gov.in
//        @license.name        Apache 2.0
//        @license.url        http://www.apache.org/licenses/LICENSE-2.0.html
//        @host                        localhost:8080
//        @BasePath                /v1
//        @schemes                http https
func main() <span class="cov0" title="0">{
        app := fx.New(
                bootstrapper.Fxconfig,
                bootstrapper.Fxlog,
                bootstrapper.FxDB,
                bootstrapper.Fxclient,
                bootstrap.Fxvalidator,
                bootstrapper.Fxrouter,
                bootstrap.FxHandler,
                bootstrap.FxRepo,
                fx.Invoke(routes.Routes),
                //bootstrapper.FxGrpc,
        )

        app.Run()

}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package repository

import (
        "context"
        "errors"

        "MgApplication/core/domain"
        "MgApplication/core/port"

        "github.com/Masterminds/squirrel"
        "github.com/gin-gonic/gin"
        "github.com/jackc/pgx/v5"
        config "MgApplication/api-config"
        dblib "MgApplication/api-db"
        log "MgApplication/api-log"
)

type ApplicationRepository struct {
        Db  *dblib.DB
        Cfg *config.Config
}

// NewOfficeRepository creates a new Office repository instance
func NewApplicationRepository(Db *dblib.DB, Cfg *config.Config) *ApplicationRepository <span class="cov8" title="1">{
        return &amp;ApplicationRepository{
                Db,
                Cfg,
        }
}</span>

// Create MsgApplication a new MsgApplication record in the database
func (ar *ApplicationRepository) CreateMsgApplicationRepo(gctx *gin.Context, msgapp *domain.MsgApplications) (domain.MsgApplications, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), ar.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var Counter domain.Counter
        var msgapplication domain.MsgApplications
        TxDB := ar.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                // Check if data already exists
                query1 := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_application").
                        Where(squirrel.Eq{"application_name": msgapp.ApplicationName})
                err := dblib.TxReturnRow(ctx, tx, query1, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error checking whether an application exists or not in CreateMsgApplication repo function: %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count &gt; 0 </span><span class="cov0" title="0">{
                        return errors.New("data already exists for this application")
                }</span>
                <span class="cov8" title="1">query2 := dblib.Psql.Insert("msg_application").
                        Columns("application_name", "request_type", "secret_key", "status_cd").
                        Values(msgapp.ApplicationName, msgapp.RequestType, msgapp.SecretKey, msgapp.Status).
                        Suffix("RETURNING application_id,application_name,request_type,created_date,updated_date,status_cd")
                err = dblib.TxReturnRow(ctx, tx, query2, pgx.RowToStructByNameLax[domain.MsgApplications], &amp;msgapplication)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing insert query in CreateMsgApplication repo function: %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Transaction rolling back in StatusMsgApplication repo function: %s", TxDB.Error())
                return domain.MsgApplications{}, TxDB
        }</span>
        <span class="cov8" title="1">return msgapplication, nil</span>
}

/*
func (ar *ApplicationRepository) ListApplicationsTx(gctx *gin.Context) ([]domain.MsgApplicationsGet, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), ar.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        var listApplications []domain.MsgApplicationsGet

        TxDB := ar.Db.WithTx(ctx, func(tx pgx.Tx) error {
                query := dblib.Psql.Select("ma.application_id", "ma.application_name", "ma.status_cd", "STRING_AGG(mr.request_type, ', ') AS request_type").
                        From("msg_application ma").
                        Join("LATERAL unnest(string_to_array(ma.request_type, ',')) AS rt(rt_value) ON true").
                        Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code").
                        GroupBy("ma.application_id", "ma.application_name", "ma.status_cd").
                        OrderBy("ma.application_id")

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.MsgApplicationsGet], &amp;listApplications)
                if err != nil {
                        log.Error(ctx, "Error executing query in ListApplications repo function: %s", err.Error())
                        return err
                }
                return nil
        })
        if TxDB != nil {
                log.Error(ctx, "Error initiating transaction in ListApplications repo function: %s", TxDB.Error())
                return nil, TxDB
        }
        return listApplications, nil
}

func (ar *ApplicationRepository) ListApplicationsOld(gctx *gin.Context) ([]domain.MsgApplicationsGet, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), ar.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        query := dblib.Psql.Select("ma.application_id", "ma.application_name", "ma.status_cd", "STRING_AGG(mr.request_type, ', ') AS request_type").
                From("msg_application ma").
                Join("LATERAL unnest(string_to_array(ma.request_type, ',')) AS rt(rt_value) ON true").
                Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code").
                GroupBy("ma.application_id", "ma.application_name", "ma.status_cd").
                OrderBy("ma.application_id")
        return dblib.SelectRows(ctx, ar.Db, query, pgx.RowToStructByNameLax[domain.MsgApplicationsGet])
}
        */

func (ar *ApplicationRepository) FetchApplicationRepo(gctx *gin.Context, msgapp *domain.MsgApplications) ([]domain.MsgApplicationsGet, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), ar.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var listApplications []domain.MsgApplicationsGet

        TxDB := ar.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                query := dblib.Psql.Select("ma.application_id", "ma.application_name", "ma.status_cd", "STRING_AGG(mr.request_type, ', ') AS request_type").
                        From("msg_application ma").
                        Join("LATERAL unnest(string_to_array(ma.request_type, ',')) AS rt(rt_value) ON true").
                        Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code").
                        Where(squirrel.Eq{"application_id": msgapp.ApplicationID}).
                        GroupBy("ma.application_id", "ma.application_name", "ma.status_cd").
                        OrderBy("ma.application_id")

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.MsgApplicationsGet], &amp;listApplications)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing query in GetAppbyID repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Error initiating transaction in GetAppbyID repo function: %s", TxDB.Error())
                return nil, TxDB
        }</span>
        <span class="cov8" title="1">return listApplications, nil</span>
}

/*
func (ar *ApplicationRepository) ListActiveApplications(gctx *gin.Context) ([]domain.MsgApplicationsGet, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), ar.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()
        query := dblib.Psql.Select("ma.application_id", "ma.application_name", "ma.status_cd", "STRING_AGG(mr.request_type, ', ') AS request_type").
                From("msg_application ma").
                Join("LATERAL unnest(string_to_array(ma.request_type, ',')) AS rt(rt_value) ON true").
                Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code").
                GroupBy("ma.application_id", "ma.application_name", "ma.status_cd").
                Where(squirrel.Eq{"status_cd": 1}).
                OrderBy("ma.application_id")
        return dblib.SelectRows(ctx, ar.Db, query, pgx.RowToStructByNameLax[domain.MsgApplicationsGet])
}

func (ar *ApplicationRepository) FetchApplications(gctx *gin.Context, applicationID uint64, activeOnly bool) ([]domain.MsgApplicationsGet, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), ar.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        // Build the base query
        query := dblib.Psql.Select("ma.application_id", "ma.application_name", "ma.status_cd", "STRING_AGG(mr.request_type, ', ') AS request_type").
                From("msg_application ma").
                Join("LATERAL unnest(string_to_array(ma.request_type, ',')) AS rt(rt_value) ON true").
                Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code")

        // Apply conditions based on the parameters
        if applicationID != 0 {
                // If an application ID is provided, filter by it
                query = query.Where(squirrel.Eq{"ma.application_id": applicationID})
        } else if activeOnly {
                // If only active applications are requested
                query = query.Where(squirrel.Eq{"ma.status_cd": 1})
        }

        query = query.GroupBy("ma.application_id", "ma.application_name", "ma.status_cd").
                OrderBy("ma.application_id")

        // Execute the query and return the results using dblib.SelectRows
        collectedRows, err := dblib.SelectRows(ctx, ar.Db, query, pgx.RowToStructByNameLax[domain.MsgApplicationsGet])
        if err != nil {
                log.Error(ctx, "Error executing query in FetchApplications repo function:  %s", err.Error())
                return nil, err
        }

        return collectedRows, nil
}
        */

func (ar *ApplicationRepository) UpdateMsgApplicationRepo(gctx *gin.Context, msgapp *domain.EditApplication) (domain.EditApplication, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), ar.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var Counter domain.Counter
        var msgapplication domain.EditApplication
        TxDB := ar.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                // Check if data already exists
                query1 := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_application").
                        Where(squirrel.Eq{"application_id": msgapp.ApplicationID})
                err := dblib.TxReturnRow(ctx, tx, query1, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error checking whether an application already exists or not in EditMsgApplication repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count == 0 </span><span class="cov0" title="0">{
                        log.Error(ctx, "No application with selected details are available")
                        return errors.New("no application with selected details available")
                }</span>
                <span class="cov8" title="1">query2 := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_application").
                        Where(squirrel.And{squirrel.Eq{"application_name": msgapp.ApplicationName}, squirrel.NotEq{"application_id": msgapp.ApplicationID}})
                err = dblib.TxReturnRow(ctx, tx, query2, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing select query in EditMsgApplication repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count &gt; 0 </span><span class="cov0" title="0">{
                        log.Error(ctx, "Already One application with the selected details already exists")
                        return errors.New("already one application with these selected details is available")
                }</span>
                <span class="cov8" title="1">query3 := dblib.Psql.Update("msg_application").
                        Set("application_name", msgapp.ApplicationName).
                        Set("request_type", msgapp.RequestType).
                        Set("status_cd", msgapp.Status).
                        Set("updated_date", squirrel.Expr("current_timestamp")).
                        Where(squirrel.Eq{"application_id": msgapp.ApplicationID}).
                        Suffix("RETURNING application_id,application_name,request_type,updated_date,status_cd")
                err = dblib.TxReturnRow(ctx, tx, query3, pgx.RowToStructByNameLax[domain.EditApplication], &amp;msgapplication)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing update query in EditMsgApplication repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Transaction rolling back in EditMsgApplication repo function:  %s", TxDB.Error())
                return domain.EditApplication{}, TxDB
        }</span>
        <span class="cov8" title="1">return msgapplication, nil</span>
}

func (ar *ApplicationRepository) ToggleApplicationStatusRepo(gctx *gin.Context, msgapp *domain.StatusApplication) (interface{}, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), ar.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var Counter domain.Counter
        TxDB := ar.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                // Check if data already exists
                query1 := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_application").
                        Where(squirrel.Eq{"application_id": msgapp.ApplicationID})
                err := dblib.TxReturnRow(ctx, tx, query1, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error checking whether an application exists or not in StatusMsgApplication repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count == 0 </span><span class="cov0" title="0">{
                        return errors.New("no application with selected details available")
                }</span>
                <span class="cov8" title="1">query2 := dblib.Psql.Update("msg_application").
                        Set("status_cd", squirrel.Expr("CASE WHEN status_cd = 0 THEN 1 ELSE 0 END")).
                        Set("updated_date", squirrel.Expr("current_timestamp")).
                        Where(squirrel.Eq{"application_id": msgapp.ApplicationID})
                err = dblib.TxExec(ctx, tx, query2)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing update query in StatusMsgApplication repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Transaction rolling back in StatusMsgApplication repo function:  %s", TxDB.Error())
                return map[string]interface{}{}, TxDB
        }</span>
        <span class="cov8" title="1">return map[string]interface{}{}, nil</span>
}

/*
func (ar *ApplicationRepository) ListActiveProvidersTx(gctx *gin.Context) ([]domain.MsgProvider, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), ar.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        var listProviders []domain.MsgProvider

        TxDB := ar.Db.WithTx(ctx, func(tx pgx.Tx) error {
                query := dblib.Psql.Select("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd", "STRING_AGG(mr.request_type, ', ') AS services").
                        From("msg_provider mp").
                        Join("LATERAL unnest(string_to_array(mp.services, ',')) AS rt(rt_value) ON true").
                        Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code").
                        Where(squirrel.Eq{"status_cd": 1}).
                        GroupBy("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd").
                        OrderBy("mp.provider_id")

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.MsgProvider], &amp;listProviders)
                if err != nil {
                        log.Error(ctx, "Error executing query in ListActiveProviders repo function:  %s", err.Error())
                        return err
                }
                return nil
        })
        if TxDB != nil {
                log.Error(ctx, "Error initiating transaction in ListActiveProviders repo function:  %s", TxDB.Error())
                return nil, TxDB
        }
        return listProviders, nil
}

func (ar *ApplicationRepository) ListActiveProviders(gctx *gin.Context) ([]domain.MsgProvider, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), ar.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        query := dblib.Psql.Select("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd", "STRING_AGG(mr.request_type, ', ') AS services").
                From("msg_provider mp").
                Join("LATERAL unnest(string_to_array(mp.services, ',')) AS rt(rt_value) ON true").
                Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code").
                Where(squirrel.Eq{"status_cd": 1}).
                GroupBy("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd").
                OrderBy("mp.provider_id")
        return dblib.SelectRows(ctx, ar.Db, query, pgx.RowToStructByNameLax[domain.MsgProvider])
}
        */

func (ar *ApplicationRepository) ListApplicationsRepo(gctx *gin.Context, msgapp domain.ListApplications, meta port.MetaDataRequest) ([]domain.MsgApplicationsGet, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), ar.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        // Build the base query
        query := dblib.Psql.Select("ma.application_id", "ma.application_name", "ma.status_cd", "STRING_AGG(mr.request_type, ', ') AS request_type").
                From("msg_application ma").
                Join("LATERAL unnest(string_to_array(ma.request_type, ',')) AS rt(rt_value) ON true").
                Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code")

                // Check the Status field for true, false, or nil
                // if msgapp.Status != nil {
                //         if *msgapp.Status {
                //                 query = query.Where(squirrel.Eq{"ma.status_cd": 1}) // Active applications
                //         } else {
                //                 query = query.Where(squirrel.Eq{"ma.status_cd": 0}) // Inactive applications
                //         }
                // }

                // Check the Status field for true, false
                //if msgapp.Status != nil {
        if msgapp.Status </span><span class="cov8" title="1">{
                query = query.Where(squirrel.Eq{"ma.status_cd": 1}) // Active applications
        }</span>
        // else {
        //         query = query.Where(squirrel.Eq{"ma.status_cd": 0}) // Inactive applications
        // }
        //}

        <span class="cov8" title="1">query = query.GroupBy("ma.application_id", "ma.application_name", "ma.status_cd").
                OrderBy("ma.application_id").
                Offset(meta.Skip * meta.Limit).
                Limit(meta.Limit)

        // Convert query to SQL string and log it
        sql, args, err := query.ToSql()
        if err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Error generating SQL query: %s", err.Error())
                return nil, err
        }</span>
        <span class="cov8" title="1">log.Debug(ctx, "SQL Query in ListApplicationsRepo: %s, Args: %v", sql, args)

        // Execute the query and collect the rows
        collectedRows, err := dblib.SelectRows(ctx, ar.Db, query, pgx.RowToStructByNameLax[domain.MsgApplicationsGet])
        if err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Error executing query in GetApplications repo function:  %s", err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">return collectedRows, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package repository

import (
        "MgApplication/core/domain"
        "context"
        "errors"
        "strconv"
        "strings"

        "github.com/Masterminds/squirrel"
        "github.com/gin-gonic/gin"
        "github.com/jackc/pgx/v5"
        dblib "MgApplication/api-db"
        log "MgApplication/api-log"
)

func (cr *MgApplicationRepository) InitiateBulkSMSRepo(gctx *gin.Context, mbulk *domain.InitiateBulkSMS) (string, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), cr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var Counter domain.Counter
        var mbulk1 domain.InitiateBulkSMS
        // var BulkSMS domain.InitiateBulkSMS
        var Template_Id, Sender_Id, Entity_Id, Message_Type string
        TxDB := cr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                // Check if data already exists
                query1 := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_template").
                        Where(squirrel.And{squirrel.Eq{"template_local_id": mbulk.TemplateName}, squirrel.Expr("? = ANY(string_to_array(application_id, ','))", mbulk.ApplicationID)})
                err := dblib.TxReturnRow(ctx, tx, query1, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error checking whether a msg_template exists for the given template_name and application_id in InitiateBulkSMS repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count == 0 </span><span class="cov8" title="1">{
                        return errors.New("application and template are not mapped, refer maintain template")
                }</span>
                <span class="cov0" title="0">query2 := dblib.Psql.Select("template_id,entity_id,sender_id,message_type").
                        From("msg_template").
                        Where("template_local_id=?", mbulk.TemplateName)
                err = dblib.TxReturnRow(ctx, tx, query2, pgx.RowToStructByNameLax[domain.InitiateBulkSMS], &amp;mbulk1)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing query in InitiateBulkSMS while collecting template_id, entity_id,sender_id and message_type: ", err)
                        return err
                }</span>
                <span class="cov0" title="0">Template_Id = mbulk1.TemplateID
                Sender_Id = mbulk1.SenderID
                Entity_Id = mbulk1.EntityID
                Message_Type = mbulk1.MessageType
                numbers := strings.Split(mbulk.MobileNo, ",")
                var mobileNumbers []int64
                for _, numStr := range numbers </span><span class="cov0" title="0">{
                        num, err := strconv.ParseInt(numStr, 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(ctx, "Error converting %s to int64: %v\n", numStr, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">mobileNumbers = append(mobileNumbers, num)</span>
                }
                <span class="cov0" title="0">query3 := dblib.Psql.Insert("msg_bulk_file").
                        Columns("application_id", "template_name", "template_id", "entity_id", "sender_id", "message_type", "mobile_number", "test_msg", "is_verified").
                        Values(mbulk.ApplicationID, mbulk.TemplateName, mbulk1.TemplateID, mbulk1.EntityID, mbulk1.SenderID, mbulk1.MessageType, mobileNumbers, mbulk.TestMessage, false).
                        Suffix("RETURNING reference_id")
                err = dblib.TxReturnRow(ctx, tx, query3, pgx.RowToStructByNameLax[domain.InitiateBulkSMS], &amp;mbulk1)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing insert query in InitiateBulkSMS repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov8" title="1">{
                log.Error(ctx, "Rolling back of transactions in InitiateBulkSMS repo function:  %s", TxDB.Error())
                return "", TxDB
        }</span>
        <span class="cov0" title="0">return Template_Id + "_" + Sender_Id + "_" + Entity_Id + "_" + Message_Type + "_" + mbulk1.ReferenceID, nil</span>
}

func (cr *MgApplicationRepository) ValidateTestSMSRepo(gctx *gin.Context, mbulk *domain.ValidateTestSMS) (bool, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), cr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var Counter domain.Counter
        TxDB := cr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                query := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_bulk_file").
                        Where(squirrel.And{squirrel.Eq{"reference_id": mbulk.ReferenceID}, squirrel.Like{"test_msg": "%" + mbulk.TestString + "%"}})
                err := dblib.TxReturnRow(ctx, tx, query, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing query in ValidateTestSMS repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count == 0 </span><span class="cov8" title="1">{
                        return errors.New("invalid test number, please refer the message sent to the mobile and enter one of the test number sent")
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov8" title="1">{
                log.Error(ctx, "Rolling Back transaction in ValidateTestSMS repo function:  %s", TxDB.Error())
                return false, TxDB
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

/*
func (cr *MgApplicationRepository) GetTemplateDetails(gctx *gin.Context, msgtemplate *domain.MaintainTemplate) ([]domain.GetTemplateformatbyID, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), cr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var listTemplates []domain.GetTemplateformatbyID

        // Start building the query
        query := dblib.Psql.Select("template_local_id", "template_name", "template_format", "template_id", "entity_id", "sender_id", "message_type").
                From("msg_template")

        // Add conditions using multiple Whe</span><span class="cov0" title="0">re clauses
        if msgtemplate.TemplateLocalID != 0 {
                </span>query = query.Where(squirrel.Eq{"template_local_id": msgtemplate.TemplateLocalID})
        <span class="cov0" title="0">}
</span>        if msgtemplate.ApplicationID != "" {
                </span>query = query.Where(squirrel.Eq{"application_id": msgtemplate.ApplicationID})
        <span class="cov0" title="0">}
</span>        if msgtemplate.TemplateFormat != "" {
                </span>query = query.Where(squirrel.Eq{"template_format": msgtemplate.TemplateFormat})
        }

        <span class="cov0" title="0">// Execute the transaction
</span>        TxDB := cr.Db.WithTx(ctx, func(tx pgx.Tx) error {
                err := dblib.T</span><span class="cov0" title="0">xRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.GetTemplateformatbyID], &amp;listTemplates)
                if err != nil {
                        log.Error(ctx, "Error executing query in GetTemplateformatbyID repo function:  %s", err.Error())
                        </span>return err
                <span class="cov0" title="0">}
</span>                return nil
        })

<span class="cov0" title="0">
</span>        if TxDB != nil {
                log.Error(ctx, "Error initiating transaction in GetTemplateformatbyID repo function:  %s", TxDB.Error())
                </span>return nil, TxDB
        }

<span class="cov0" title="0">
</span>        return listTemplates, nil
}
        */
</pre>
		
		<pre class="file" id="file19" style="display: none">package repository

import (
        "context"
        "errors"
        "strconv"
        "strings"

        "MgApplication/core/domain"

        "github.com/Masterminds/squirrel"
        "github.MgApplication
        "githubMgApplication
        confiMgApplicationmon/api-config"
        dblib "MgApplication/api-db"
        log "MgApplication/api-log"
)

type MgApplicationRepository struct {
        Db  *dblib.DB
        Cfg *config.Config
}

// NewOfficeRepository creates a new Office repository instance
func NewMgApplicationRepository(Db *dblib.DB, Cfg *config.Config) *MgApplicationRepository <span class="cov8" title="1">{
        return &amp;MgApplicationRepository{
                Db,
                Cfg,
        }
}</span>

func (cr *MgApplicationRepository) SaveMsgRequest(gctx *gin.Context, msgapp *domain.MsgRequest) (*domain.MsgRequest, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), cr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        log.Debug(nil, "Inside SaveMsgRequest Repo function")

        var Counter domain.Counter
        var msgreq1 domain.MsgRequest

        TxDB := cr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                //checking whether applicaiton exists in the database
                query1 := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_application").
                        Where(squirrel.Eq{"application_id": msgapp.ApplicationID})
                err := dblib.TxReturnRow(ctx, tx, query1, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error checking existence of application in msg_application table in SaveMsgRequest: %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count == 0 </span><span class="cov0" title="0">{
                        return errors.New("application does not exists")
                }</span>
                //checking whether application and templateid combination available or not
                // query2 := dblib.Psql.Select("COUNT(1) as count").
                //         From("msg_template").
                //         Where(squirrel.And{squirrel.Eq{"ANY(string_to_array(application_id,','))": msgapp.ApplicationID}, squirrel.Eq{"template_id": msgapp.TemplateID}})

                <span class="cov8" title="1">query2 := dblib.Psql.Select("COUNT(1) AS count").
                        From("msg_template").
                        Where(
                                squirrel.Expr(
                                        "EXISTS (SELECT 1 FROM unnest(string_to_array(application_id, ',')) AS app_id WHERE app_id = ?)",
                                        msgapp.ApplicationID,
                                ),
                        ).
                        Where("template_id = ?", msgapp.TemplateID)
                err = dblib.TxReturnRow(ctx, tx, query2, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error checking whether a template registered for an application in SaveMsgRequest function: %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count == 0 </span><span class="cov0" title="0">{
                        return errors.New("application and template are not mapped. Contact CEPT")
                }</span>
                <span class="cov8" title="1">numbers := strings.Split(msgapp.MobileNumbers, ",")
                var mobileNumbers []int64
                for _, numStr := range numbers </span><span class="cov8" title="1">{
                        num, err := strconv.ParseInt(numStr, 10, 64)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(ctx, "Error converting %s to int64: %v\n", numStr, err)
                                continue</span>
                        }
                        <span class="cov8" title="1">mobileNumbers = append(mobileNumbers, num)</span>
                }
                // Check if data already exists
                // Insert into msg_request and retrieve the gateway
                <span class="cov8" title="1">query3 := dblib.Psql.Insert("msg_request").
                        Columns("gateway", "application_id", "facility_id", "message_text", "sender_id", "entity_id", "template_id", "status", "priority", "mobile_number").
                        Select(dblib.Psql.Select("mt.gateway").
                                Column(squirrel.Expr("? as application_id, ? as facility_id, ? as message_text, ? as sender_id, ? as entity_id, ? as template_id, ? as status, ? as priority, ? as mobile_number",
                                        msgapp.ApplicationID, msgapp.FacilityID, msgapp.MessageText, msgapp.SenderID, msgapp.EntityId, msgapp.TemplateID, "pending", msgapp.Priority, mobileNumbers)).
                                From("msg_template mt").
                                Where(squirrel.Eq{"mt.template_id": msgapp.TemplateID})).
                        Suffix(`RETURNING "request_id", "communication_id", "gateway"`)

                msgreq1, err = dblib.InsertReturning(ctx, cr.Db, query3, pgx.RowToStructByNameLax[domain.MsgRequest])
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "error executing insert query in SaveMsgRequest repo function: %w", err)
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Transaction rolling back in SaveMsgRequest repo function:  %s", TxDB.Error())
                return &amp;domain.MsgRequest{}, TxDB
        }</span>
        <span class="cov8" title="1">msgapp.Gateway = msgreq1.Gateway
        msgapp.CommunicationID = msgreq1.CommunicationID
        msgapp.RequestID = msgreq1.RequestID
        return msgapp, nil</span>
}

func (cr *MgApplicationRepository) GetGateway(gctx *gin.Context, msgreq *domain.MsgRequest) (*domain.MsgRequest, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), cr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var Counter domain.Counter
        var msgreq1 domain.MsgRequest
        TxDB := cr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov0" title="0">{
                query1 := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_template").
                        Where(squirrel.Eq{"template_id": msgreq.TemplateID})
                err := dblib.TxReturnRow(ctx, tx, query1, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error checking whether a template exists or not in GetGateway repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov0" title="0">if Counter.Count == 0 </span><span class="cov0" title="0">{
                        return errors.New("template does not exists, hence cannot continue")
                }</span>
                <span class="cov0" title="0">query2 := dblib.Psql.Select(`0 as req_id, 'Not Applicable' as communication_id, gateway, entity_id, message_type`).
                        From("msg_template").
                        Where(squirrel.Eq{"template_id": msgreq.TemplateID})
                err = dblib.TxReturnRow(ctx, tx, query2, pgx.RowToStructByNameLax[domain.MsgRequest], &amp;msgreq1)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing query in GetGateway repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Transaction rolling back in GetGateway repo function:  %s", TxDB.Error())
                return &amp;domain.MsgRequest{}, TxDB
        }</span>
        <span class="cov0" title="0">msgreq.RequestID = msgreq1.RequestID
        msgreq.CommunicationID = msgreq1.CommunicationID
        msgreq.Gateway = msgreq1.Gateway
        msgreq.EntityId = msgreq1.EntityId
        msgreq.MessageType = msgreq1.MessageType
        return msgreq, nil</span>
}

func (cr *MgApplicationRepository) SaveGatewayDetails(gctx *gin.Context, Gateway string, CommunicationID string) (bool, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), cr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        TxDB := cr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov0" title="0">{
                query := dblib.Psql.Update("msg_request").
                        Set("gateway", Gateway).
                        Set("updated_date", squirrel.Expr("current_timestamp")).
                        Where(squirrel.Eq{"communication_id": CommunicationID})

                err := dblib.TxExec(ctx, tx, query)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing update query in SaveGatewayDetails repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Error initiating transaction in SaveGatewayDetails repo function:  %s", TxDB.Error())
                return false, TxDB
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (cr *MgApplicationRepository) SaveResponse(gctx *gin.Context, msgRsp *domain.MsgResponse) (bool, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), cr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        TxDB := cr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                query := dblib.Psql.Update("msg_request").
                        Set("status", "submitted").
                        Set("updated_date", squirrel.Expr("current_timestamp")).
                        Set("reference_id", msgRsp.ReferenceID).
                        Set("response_code", msgRsp.ResponseCode).
                        Set("response_message", msgRsp.ResponseText).
                        Set("complete_response", msgRsp.CompleteResponse).
                        Where(squirrel.Eq{"communication_id": msgRsp.CommunicationID})
                err := dblib.TxExec(ctx, tx, query)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing update query in SaveResponse repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Error initiating transaction in SaveResponse repo function:  %s", TxDB.Error())
                return false, TxDB
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package repository

import (
        "context"
        "errors"

        "MgApplication/core/domain"
        "MgApplication/core/port"

        "github.com/Masterminds/squirrel"
        "github.MgApplication
        "githubMgApplication
        confiMgApplicationmon/api-config"
        dblib "MgApplication/api-db"
        log "MgApplication/api-log"
)

type ProviderRepository struct {
        Db  *dblib.DB
        Cfg *config.Config
}

// NewOfficeRepository preates a new Office repository instance
func NewProviderRepository(Db *dblib.DB, Cfg *config.Config) *ProviderRepository <span class="cov8" title="1">{
        return &amp;ProviderRepository{
                Db,
                Cfg,
        }
}</span>

func (pr *ProviderRepository) CreateMessageProviderRepo(gctx *gin.Context, msgprovider *domain.MsgProvider) (domain.MsgProvider, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), pr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var Counter domain.Counter
        var msgProvider1 domain.MsgProvider
        TxDB := pr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                // Check if data already exists
                query1 := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_provider").
                        Where(squirrel.Eq{"provider_name": msgprovider.ProviderName})
                err := dblib.TxReturnRow(ctx, tx, query1, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error checking whether a provider already exists with the inputted provider_name in CreateMsgProvider: %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count &gt; 0 </span><span class="cov8" title="1">{
                        return errors.New("provider already exists, cannot save")
                }</span>
                <span class="cov8" title="1">query2 := dblib.Psql.Insert("msg_provider").
                        Columns("provider_name", "short_name", "services", "configuration_key", "status_cd").
                        Values(msgprovider.ProviderName, msgprovider.ShortName, msgprovider.Services, msgprovider.ConfigurationKeys, msgprovider.Status).
                        Suffix("RETURNING provider_id, provider_name,short_name, services, configuration_key, status_cd")
                err = dblib.TxReturnRow(ctx, tx, query2, pgx.RowToStructByNameLax[domain.MsgProvider], &amp;msgProvider1)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing insert query in CreateMsgProvider repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov8" title="1">{
                log.Error(ctx, "Transaction rolling back in CreateMsgProvider repo function:  %s", TxDB.Error())
                return domain.MsgProvider{}, TxDB
        }</span>
        <span class="cov8" title="1">return msgProvider1, nil</span>
}

/*
func (pr *ProviderRepository) ListProvidersTx(gctx *gin.Context) ([]domain.MsgProvider, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), pr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        var listProviders []domain.MsgProvider

        TxDB := pr.Db.WithTx(ctx, func(tx pgx.Tx) error {
                query := dblib.Psql.Select("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd", "STRING_AGG(mr.request_type, ', ') AS services").
                        From("msg_provider mp").
                        Join("LATERAL unnest(string_to_array(mp.services, ',')) AS rt(rt_value) ON true").
                        Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code").
                        GroupBy("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd").
                        OrderBy("mp.provider_id")

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.MsgProvider], &amp;listProviders)
                if err != nil {
                        log.Error(ctx, "Error executing query in ListProviders repo function:  %s", err.Error())
                        return err
                }
                return nil
        })
        if TxDB != nil {
                log.Error(ctx, "Error initiating transaction in ListProviders repo function:  %s", TxDB.Error())
                return nil, TxDB
        }
        return listProviders, nil
}

func (pr *ProviderRepository) ListProvidersOld(gctx *gin.Context) ([]domain.MsgProvider, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), pr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        query := dblib.Psql.Select("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd", "STRING_AGG(mr.request_type, ', ') AS services").
                From("msg_provider mp").
                Join("LATERAL unnest(string_to_array(mp.services, ',')) AS rt(rt_value) ON true").
                Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code").
                GroupBy("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd").
                OrderBy("mp.provider_id")
        return dblib.SelectRows(ctx, pr.Db, query, pgx.RowToStructByNameLax[domain.MsgProvider])
}
*/

func (pr *ProviderRepository) FetchMessageProviderRepo(gctx *gin.Context, msgprovider *domain.MsgProvider) ([]domain.MsgProvider, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), pr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var listProviders []domain.MsgProvider

        TxDB := pr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                query := dblib.Psql.Select("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd", "STRING_AGG(mr.request_type, ', ') AS services").
                        From("msg_provider mp").
                        Join("LATERAL unnest(string_to_array(mp.services, ',')) AS rt(rt_value) ON true").
                        Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code").
                        Where(squirrel.Eq{"provider_id": msgprovider.ProviderID}).
                        GroupBy("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd").
                        OrderBy("mp.provider_id")

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.MsgProvider], &amp;listProviders)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing query in GetProviderbyID repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Error initiating transaction in GetProviderbyID repo function:  %s", TxDB.Error())
                return nil, TxDB
        }</span>
        <span class="cov8" title="1">return listProviders, nil</span>
}

/*
func (pr *ProviderRepository) ListActiveProvidersTx(gctx *gin.Context) ([]domain.MsgProvider, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), pr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        var listProviders []domain.MsgProvider

        TxDB := pr.Db.WithTx(ctx, func(tx pgx.Tx) error {
                query := dblib.Psql.Select("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd", "STRING_AGG(mr.request_type, ', ') AS services").
                        From("msg_provider mp").
                        Join("LATERAL unnest(string_to_array(mp.services, ',')) AS rt(rt_value) ON true").
                        Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code").
                        Where(squirrel.Eq{"status_cd": 1}).
                        GroupBy("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd").
                        OrderBy("mp.provider_id")

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.MsgProvider], &amp;listProviders)
                if err != nil {
                        log.Error(ctx, "Error executing query in ListActiveProviders repo function:  %s", err.Error())
                        return err
                }
                return nil
        })
        if TxDB != nil {
                log.Error(ctx, "Error initiating transaction in ListActiveProviders repo function:  %s", TxDB.Error())
                return nil, TxDB
        }
        return listProviders, nil
}
        */

func (pr *ProviderRepository) UpdateMessageProviderRepo(gctx *gin.Context, msgprovider *domain.MsgProvider) (domain.MsgProvider, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), pr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var Counter domain.Counter
        var msgProvider1 domain.MsgProvider
        TxDB := pr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                // Check if data already exists
                query1 := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_provider").
                        Where(squirrel.Eq{"provider_id": msgprovider.ProviderID})
                err := dblib.TxReturnRow(ctx, tx, query1, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error checking whether a provider already exists with given provider_id in EditMsgProvider repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count == 0 </span><span class="cov0" title="0">{
                        return errors.New("provider does not exists, cannot update")
                }</span>
                <span class="cov8" title="1">query2 := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_provider").
                        Where(squirrel.And{squirrel.Eq{"provider_name": msgprovider.ProviderName}, squirrel.NotEq{"provider_id": msgprovider.ProviderID}})
                err = dblib.TxReturnRow(ctx, tx, query2, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error checking whether a provider with the given provider name already exists for given provider_id in EditMsgProvider repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count &gt; 0 </span><span class="cov0" title="0">{
                        return errors.New("already one application with these selected details is available")
                }</span>
                <span class="cov8" title="1">query3 := dblib.Psql.Update("msg_provider").
                        Set("provider_name", msgprovider.ProviderName).
                        Set("services", msgprovider.Services).
                        Set("status_cd", msgprovider.Status).
                        Where(squirrel.Eq{"provider_id": msgprovider.ProviderID}).
                        Suffix("RETURNING provider_id,provider_name,services,status_cd")
                err = dblib.TxReturnRow(ctx, tx, query3, pgx.RowToStructByNameLax[domain.MsgProvider], &amp;msgProvider1)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing Update query in EditMsgProvider repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Transaction rolling back in EditMsgProvider repo function:  %s", TxDB.Error())
                return domain.MsgProvider{}, TxDB
        }</span>
        <span class="cov8" title="1">return msgProvider1, nil</span>
}

func (pr *ProviderRepository) ToggleMessageProviderStatusRepo(gctx *gin.Context, msgprovider *domain.StatusProvider) (interface{}, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), pr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var Counter domain.Counter
        var CurrentStatus domain.CurrentStatus
        TxDB := pr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                // Check if data already exists
                query1 := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_provider").
                        Where(squirrel.Eq{"provider_id": msgprovider.ProviderID})
                err := dblib.TxReturnRow(ctx, tx, query1, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error checking whether provider already exists for the given provider_id in StatusMsgProvider repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count == 0 </span><span class="cov0" title="0">{
                        return errors.New("no provider with selected details available")
                }</span>
                // Retrieve the current status of the provider
                <span class="cov8" title="1">query2 := dblib.Psql.Select("status_cd").
                        From("msg_provider").
                        Where(squirrel.Eq{"provider_id": msgprovider.ProviderID})
                err = dblib.TxReturnRow(ctx, tx, query2, pgx.RowToStructByNameLax[domain.CurrentStatus], &amp;CurrentStatus)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error checking the status of message provider in StatusMsgProvider repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if CurrentStatus.Status == 1 </span><span class="cov8" title="1">{
                        // The current status is 1, check for dependent applications
                        query3 := dblib.Psql.Select("COUNT(1) as count").
                                From("msg_template").
                                Where(squirrel.Eq{"gateway::int": msgprovider.ProviderID})
                        err := dblib.TxReturnRow(ctx, tx, query3, pgx.RowToStructByNameLax[domain.Counter], &amp;Counter)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error(ctx, "Error checking whether any template exists for the given provider in StatusMsgProvider repo function:  %s", err.Error())
                                return err
                        }</span>
                        <span class="cov8" title="1">if Counter.Count &gt; 0 </span><span class="cov0" title="0">{
                                // There are dependent applications with status 1, cannot update the provider status
                                return errors.New("cannot disable the provider as there are some messages which are mapped to it")
                        }</span>
                }
                <span class="cov8" title="1">query4 := dblib.Psql.Update("msg_provider").
                        Set("status_cd", squirrel.Expr("CASE WHEN status_cd = 0 THEN 1 ELSE 0 END")).
                        Where(squirrel.Eq{"provider_id": msgprovider.ProviderID})
                err = dblib.TxExec(ctx, tx, query4)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(ctx, "Error executing update query in StatusMsgProvider repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Transaction rolling back in StatusMsgProvider repo function:  %s", TxDB.Error())
                return map[string]interface{}{}, TxDB
        }</span>
        <span class="cov8" title="1">return map[string]interface{}{}, nil</span>
}

/*
func (pr *ProviderRepository) ListActiveProviders(gctx *gin.Context) ([]domain.MsgProvider, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), pr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        query := dblib.Psql.Select("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd", "STRING_AGG(mr.request_type, ', ') AS services").
                From("msg_provider mp").
                Join("LATERAL unnest(string_to_array(mp.services, ',')) AS rt(rt_value) ON true").
                Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code").
                Where(squirrel.Eq{"status_cd": 1}).
                GroupBy("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd").
                OrderBy("mp.provider_id")
        return dblib.SelectRows(ctx, pr.Db, query, pgx.RowToStructByNameLax[domain.MsgProvider])
}
        */

func (pr *ProviderRepository) ListMessageProvidersRepo(gctx *gin.Context, msgreq domain.ListMessageProviders, meta port.MetaDataRequest) ([]domain.MsgProvider, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), pr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        // Build the base query
        query := dblib.Psql.Select("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd", "STRING_AGG(mr.request_type, ', ') AS services").
                From("msg_provider mp").
                Join("LATERAL unnest(string_to_array(mp.services, ',')) AS rt(rt_value) ON true").
                Join("msg_request_type mr ON rt.rt_value::integer = mr.request_code")

                // Check the Status field for true, false, or nil
                // if msgreq.Status != nil {
        if msgreq.Status </span><span class="cov0" title="0">{
                query = query.Where(squirrel.Eq{"mp.status_cd": 1}) // Active applications
        }</span>
        // else {
        //         query = query.Where(squirrel.Eq{"mp.status_cd": 0}) // Inactive applications
        // }
        // }
        // Group and order the results
        <span class="cov8" title="1">query = query.GroupBy("mp.provider_id", "mp.provider_name", "mp.short_name", "mp.status_cd").
                OrderBy("mp.provider_id").
                Offset(meta.Skip * meta.Limit).
                Limit(meta.Limit)

        // Execute the query and collect the rows
        collectedRows, err := dblib.SelectRows(ctx, pr.Db, query, pgx.RowToStructByNameLax[domain.MsgProvider])
        if err != nil </span><span class="cov0" title="0">{
                log.Error(ctx, "Error executing query in ListProvidersConditional repo function:  %s", err.Error())
                return nil, err
        }</span>

        <span class="cov8" title="1">return collectedRows, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package repository

import (
        "context"
        "time"

        "MgApplication/core/domain"
        "MgApplication/core/port"

        "github.com/Masterminds/squirrel"
        "github.MgApplication
        "githubMgApplication
        confiMgApplicationmon/api-config"
        dblib "MgApplication/api-db"
        log "MgApplication/api-log"
)

type ReportsRepository struct {
        Db  *dblib.DB
        Cfg *config.Config
}

// NewOfficeRepository creates a new Office repository instance
func NewReportsRepository(Db *dblib.DB, Cfg *config.Config) *ReportsRepository <span class="cov8" title="1">{
        return &amp;ReportsRepository{
                Db,
                Cfg,
        }
}</span>

func (cr *ReportsRepository) SMSSentStatusReportRepo(gctx *gin.Context, fromDate time.Time, toDate time.Time, meta port.MetaDataRequest) ([]domain.SMSReport, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), cr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        var sms []domain.SMSReport
        TxDB := cr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                query := dblib.Psql.Select("row_number() over(ORDER BY created_date ASC) as serial_number", "created_date", "communication_id", "application_id", "facility_id", "priority", "message_text", "unnest(mr.mobile_number) AS mobile_number", "gateway", "status").
                        From("msg_request mr").
                        Where(squirrel.And{squirrel.GtOrEq{"created_date::date": fromDate}, squirrel.LtOrEq{"created_date::date": toDate}}).
                        OrderBy("created_date ASC").
                        Offset(meta.Skip * meta.Limit).
                        Limit(meta.Limit)

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.SMSReport], &amp;sms)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(gctx, "Error in SMSSentStatusReport repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(gctx, "Error initiating transaction in SMSSentStatusReport repo function:  %s", TxDB.Error())
                return nil, TxDB
        }</span>
        <span class="cov8" title="1">return sms, nil</span>
}

func (cr *ReportsRepository) AppwiseSMSUsageReportRepo(gctx *gin.Context, fromDate time.Time, toDate time.Time, meta port.MetaDataRequest) ([]domain.SMSAggregateReport, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), cr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        var sms []domain.SMSAggregateReport
        TxDB := cr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                query := dblib.Psql.Select("row_number() over(ORDER BY mr.created_date::date ASC) as serial_number",
                        "ma.application_name",
                        "mr.created_date::date",
                        "COUNT(*) AS total_sms, COUNT(CASE WHEN mr.status = 'submitted' THEN 1 END) AS success, COUNT(CASE WHEN mr.status &lt;&gt; 'submitted' THEN 1 END) AS failed").
                        From("msg_request mr").
                        Join("msg_application ma ON mr.application_id::int = ma.application_id").
                        Join("unnest(mr.mobile_number) AS mobile_number ON true").
                        Where(squirrel.And{squirrel.GtOrEq{"mr.created_date::date": fromDate}, squirrel.LtOrEq{"mr.created_date::date": toDate}}).
                        GroupBy("ma.application_name,mr.created_date::date").
                        OrderBy("mr.created_date::date ASC").
                        Offset(meta.Skip * meta.Limit).
                        Limit(meta.Limit)

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.SMSAggregateReport], &amp;sms)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(gctx, "Error in Appwise SMS Usage Report repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(gctx, "Error initiating transaction in Appwise SMS Usage Report repo function:  %s", TxDB.Error())
                return nil, TxDB
        }</span>

        <span class="cov8" title="1">return sms, nil</span>
}

func (cr *ReportsRepository) TemplatewiseSMSUsageReportRepo(gctx *gin.Context, fromDate time.Time, toDate time.Time, meta port.MetaDataRequest) ([]domain.SMSAggregateReport, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), cr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        var sms []domain.SMSAggregateReport
        TxDB := cr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                query := dblib.Psql.Select("row_number() over(ORDER BY mr.created_date::date ASC) as serial_number", "ma.template_name", "mr.created_date::date", "COUNT(*) AS total_sms, COUNT(CASE WHEN mr.status = 'submitted' THEN 1 END) AS success, COUNT(CASE WHEN mr.status &lt;&gt; 'submitted' THEN 1 END) AS failed").
                        From("msg_request mr").
                        Join("msg_template ma ON mr.template_id = ma.template_id").
                        Join("unnest(mr.mobile_number) AS mobile_number ON true").
                        Where(squirrel.And{squirrel.GtOrEq{"mr.created_date::date": fromDate}, squirrel.LtOrEq{"mr.created_date::date": toDate}}).
                        GroupBy("ma.template_name,mr.created_date::date").
                        OrderBy("mr.created_date::date ASC").
                        Offset(meta.Skip * meta.Limit).
                        Limit(meta.Limit)

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.SMSAggregateReport], &amp;sms)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(gctx, "Error in Templatewise SMS Usage Report repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(gctx, "Error initiating transaction in Templatewise SMS Usage Report repo function:  %s", TxDB.Error())
                return nil, TxDB
        }</span>

        <span class="cov8" title="1">return sms, nil</span>
}

func (cr *ReportsRepository) ProviderwiseSMSUsageReportRepo(gctx *gin.Context, fromDate time.Time, toDate time.Time, meta port.MetaDataRequest) ([]domain.SMSAggregateReport, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), cr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        var sms []domain.SMSAggregateReport
        TxDB := cr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                query := dblib.Psql.Select("row_number() over(ORDER BY mr.created_date::date ASC) as serial_number", "ma.provider_name", "mr.created_date::date", "COUNT(*) AS total_sms, COUNT(CASE WHEN mr.status = 'submitted' THEN 1 END) AS success, COUNT(CASE WHEN mr.status &lt;&gt; 'submitted' THEN 1 END) AS failed").
                        From("msg_request mr").
                        Join("msg_provider ma ON mr.gateway::int = ma.provider_id").
                        Join("unnest(mr.mobile_number) AS mobile_number ON true").
                        Where(squirrel.And{squirrel.GtOrEq{"mr.created_date::date": fromDate}, squirrel.LtOrEq{"mr.created_date::date": toDate}}).
                        GroupBy("ma.provider_name,mr.created_date::date").
                        OrderBy("mr.created_date::date ASC").
                        Offset(meta.Skip * meta.Limit).
                        Limit(meta.Limit)

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.SMSAggregateReport], &amp;sms)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(gctx, "Error in Provider wise SMS Usage Report repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(gctx, "Error initiating transaction in Provider wise SMS Usage Report repo function:  %s", TxDB.Error())
                return nil, TxDB
        }</span>

        <span class="cov8" title="1">return sms, nil</span>
}

/*
// with transaction model
func (cr *ReportsRepository) SMSDashboard2(gctx *gin.Context) (domain.SMSDashboard, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), cr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        var sms domain.SMSDashboard

        TxDB := cr.Db.WithTx(ctx, func(tx pgx.Tx) error {
                query := dblib.Psql.Select(
                        //"COUNT(*) as total_requests",
                        //"count(*) as total_sms_sent",
                        "SUM(COALESCE(array_length(mr.mobile_number, 1), 0)) as total_sms_sent",
                        //"sum(case when mr.priority=1 then 1 else 0 end) as total_otps",
                        "SUM(CASE WHEN mr.priority=1 THEN COALESCE(array_length(mr.mobile_number, 1), 0) ELSE 0 END) as total_otps",
                        //"sum(case when mr.priority=2 then 1 else 0 end) as total_transactions",
                        "SUM(CASE WHEN mr.priority=2 THEN COALESCE(array_length(mr.mobile_number, 1), 0) ELSE 0 END) as total_transactions",
                        //"sum(case when mr.priority=3 then 1 else 0 end) as total_bulk_sms",
                        "SUM(CASE WHEN mr.priority=3 THEN COALESCE(array_length(mr.mobile_number, 1), 0) ELSE 0 END) as total_bulk_sms",
                        //"sum(case when mr.priority=4 then 1 else 0 end) as total_promotional_sms",
                        "SUM(CASE WHEN mr.priority=4 THEN COALESCE(array_length(mr.mobile_number, 1), 0) ELSE 0 END) as total_promotional_sms",
                        "(select Count(*) from msg_template as mt where mt.status_cd=1)as total_templates",
                        "(select count(*) from msg_provider mp where mp.status_cd=1) as total_providers",
                        "(select count(*) from msg_application ma where ma.status_cd=1) as total_applications").
                        From("msg_request as mr")

                err := dblib.TxReturnRow(ctx, tx, query, pgx.RowToStructByNameLax[domain.SMSDashboard], &amp;sms)
                if err != nil {
                        log.Error(gctx, "Error in SMS Dashboard repo function:  %s", err.Error())
                        return err
                }
                return nil
        })
        if TxDB != nil {
                log.Error(gctx, "Error initiating transaction in SMSDashboard repo function:  %s", TxDB.Error())
                return domain.SMSDashboard{}, TxDB
        }
        return sms, nil
}
        */

// without transaction model
func (cr *ReportsRepository) SMSDashboardRepo(gctx *gin.Context) (domain.SMSDashboard, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), cr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        query := dblib.Psql.Select(
                //"COUNT(*) as total_requests",
                //"count(*) as total_sms_sent",
                "SUM(COALESCE(array_length(mr.mobile_number, 1), 0)) as total_sms_sent",
                //"sum(case when mr.priority=1 then 1 else 0 end) as total_otps",
                "SUM(CASE WHEN mr.priority=1 THEN COALESCE(array_length(mr.mobile_number, 1), 0) ELSE 0 END) as total_otps",
                //"sum(case when mr.priority=2 then 1 else 0 end) as total_transactions",
                "SUM(CASE WHEN mr.priority=2 THEN COALESCE(array_length(mr.mobile_number, 1), 0) ELSE 0 END) as total_transactions",
                //"sum(case when mr.priority=3 then 1 else 0 end) as total_bulk_sms",
                "SUM(CASE WHEN mr.priority=3 THEN COALESCE(array_length(mr.mobile_number, 1), 0) ELSE 0 END) as total_bulk_sms",
                //"sum(case when mr.priority=4 then 1 else 0 end) as total_promotional_sms",
                "SUM(CASE WHEN mr.priority=4 THEN COALESCE(array_length(mr.mobile_number, 1), 0) ELSE 0 END) as total_promotional_sms",
                "(select Count(*) from msg_template as mt where mt.status_cd=1)as total_templates",
                "(select count(*) from msg_provider mp where mp.status_cd=1) as total_providers",
                "(select count(*) from msg_application ma where ma.status_cd=1) as total_applications").
                From("msg_request as mr")
        return dblib.SelectOne(ctx, cr.Db, query, pgx.RowToStructByNameLax[domain.SMSDashboard])
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package repository

import (
        "context"
        "errors"
        "fmt"

        "MgApplication/core/domain"

        "github.com/Masterminds/squirrel"
        "github.MgApplication
        "githubMgApplication
        confiMgApplicationmon/api-config"
        dblib "MgApplication/api-db"
        log "MgApplication/api-log"
)

type TemplateRepository struct {
        Db  *dblib.DB
        Cfg *config.Config
}

func NewTemplateRepository(Db *dblib.DB, Cfg *config.Config) *TemplateRepository <span class="cov8" title="1">{
        return &amp;TemplateRepository{
                Db,
                Cfg,
        }
}</span>


func (tr *TemplateRepository) CreateTemplateRepo(gctx *gin.Context, mtemplate *domain.MaintainTemplate) error <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var Counter domain.Counter
        TxDB := tr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov0" title="0">{
                // Check if data already exists
                query := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_template").
                        Where(squirrel.Eq{"template_id": mtemplate.TemplateID})
                err := dblib.TxReturnRow(ctx, tx, query, pgx.RowToStructByPos[domain.Counter], &amp;Counter)

                if err != nil </span><span class="cov0" title="0">{
                        log.Error(gctx, "Error checking whether a msg template exists for the given template_id in MaintainTemplate repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov0" title="0">if Counter.Count &gt; 0 </span><span class="cov0" title="0">{
                        return errors.New("given template_id and template already exists, cannot continue")
                }</span>
                <span class="cov0" title="0">uquery := dblib.Psql.Insert("msg_template").
                        Columns("application_id", "template_name", "template_format", "entity_id", "sender_id", "template_id", "gateway", "message_type", "status_cd").
                        Values(mtemplate.ApplicationID, mtemplate.TemplateName, mtemplate.TemplateFormat, mtemplate.EntityID, mtemplate.SenderID, mtemplate.TemplateID, mtemplate.Gateway, mtemplate.MessageType, mtemplate.Status)
                err = dblib.TxExec(ctx, tx, uquery)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(gctx, "Error executing insert query in MaintainTemplate repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(gctx, "Transaction rolling back in MaintainTemplate repo function:  %s", TxDB.Error())
                return TxDB
        }</span>
        <span class="cov0" title="0">return nil</span>
}

/*
func (tr *TemplateRepository) ListTemplates2(gctx *gin.Context) ([]domain.MaintainTemplate, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        var listTemplates []domain.MaintainTemplate

        TxDB := tr.Db.WithTx(ctx, func(tx pgx.Tx) error {
                query := dblib.Psql.Select("mt.template_local_id", "STRING_AGG(ma.application_name, ', ') AS application_id", "mt.template_name", "mt.template_format", "mt.sender_id", "mt.entity_id", "mt.template_id", "mp.provider_name AS gateway", "mt.status_cd").
                        From("msg_template mt").
                        Join("LATERAL unnest(string_to_array(mt.application_id, ',')) AS rt(rt_value) ON true").
                        Join("msg_application ma ON rt.rt_value::integer = ma.application_id").
                        Join("msg_provider mp on mp.provider_id=mt.gateway::integer").
                        GroupBy("mt.template_local_id", "mt.template_name", "mt.template_format", "mt.sender_id", "mt.entity_id", "mt.template_id", "mp.provider_name", "mt.status_cd").
                        OrderBy("mt.template_local_id")

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.MaintainTemplate], &amp;listTemplates)
                if err != nil {
                        log.Error(gctx, "Error executing query in ListTemplates repo function:  %s", err.Error())
                        return err
                }
                return nil
        })
        if TxDB != nil {
                log.Error(gctx, "Error initiating transaction in ListTemplates repo function:  %s", TxDB.Error())
                return nil, TxDB
        }
        return listTemplates, nil
}

func (tr *TemplateRepository) ListTemplatesOld(gctx *gin.Context) ([]domain.MaintainTemplate, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        query := dblib.Psql.Select("mt.template_local_id", "STRING_AGG(ma.application_name, ', ') AS application_id", "mt.template_name", "mt.template_format", "mt.sender_id", "mt.entity_id", "mt.template_id", "mt.message_type", "mp.provider_name AS gateway", "mt.status_cd").
                From("msg_template mt").
                Join("LATERAL unnest(string_to_array(mt.application_id, ',')) AS rt(rt_value) ON true").
                Join("msg_application ma ON rt.rt_value::integer = ma.application_id").
                Join("msg_provider mp on mp.provider_id=mt.gateway::integer").
                GroupBy("mt.template_local_id", "mt.template_name", "mt.template_format", "mt.sender_id", "mt.entity_id", "mt.template_id", "mt.message_type", "mp.provider_name", "mt.status_cd").
                OrderBy("mt.template_local_id")
        return dblib.SelectRows(ctx, tr.Db, query, pgx.RowToStructByNameLax[domain.MaintainTemplate])
}

func (tr *TemplateRepository) ListTemplatesLimit(gctx *gin.Context, listTemplate *domain.Meta) ([]domain.MaintainTemplate, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        query := dblib.Psql.Select("mt.template_local_id", "STRING_AGG(ma.application_name, ', ') AS application_id",
                "mt.template_name", "mt.template_format", "mt.sender_id", "mt.entity_id", "mt.template_id", "mt.message_type",
                "mp.provider_name AS gateway", "mt.status_cd").
                From("msg_template mt").
                Join("LATERAL unnest(string_to_array(mt.application_id, ',')) AS rt(rt_value) ON true").
                Join("msg_application ma ON rt.rt_value::integer = ma.application_id").
                Join("msg_provider mp on mp.provider_id=mt.gateway::integer").
                GroupBy("mt.template_local_id", "mt.template_name", "mt.template_format", "mt.sender_id", "mt.entity_id", "mt.template_id", "mt.message_type", "mp.provider_name", "mt.status_cd").
                OrderBy("mt.template_local_id").
                Limit(listTemplate.Limit).
                Offset(listTemplate.Skip)

        return dblib.SelectRows(ctx, tr.Db, query, pgx.RowToStructByNameLax[domain.MaintainTemplate])
}
        */

func (tr *TemplateRepository) ListTemplatesRepo(gctx *gin.Context, listTemplate *domain.Meta) ([]domain.MaintainTemplate, uint64, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutmed"))
        defer cancel()

        var totalCount uint64

        // Create the subquery for counting total templates
        subquery, _, _ := dblib.Psql.Select("COUNT(*) AS total_count").
                From("msg_template").
                ToSql()

        // Build the main query to fetch the templates with pagination and total_count from the subquery
        query := dblib.Psql.Select("mt.template_local_id", "STRING_AGG(ma.application_name, ', ') AS application_id",
                "mt.template_name", "mt.template_format", "mt.sender_id", "mt.entity_id", "mt.template_id",
                "mt.message_type", "mp.provider_name AS gateway", "mt.status_cd", fmt.Sprintf("(%s) AS total_count", subquery)).
                From("msg_template mt").
                Join("LATERAL unnest(string_to_array(mt.application_id, ',')) AS rt(rt_value) ON true").
                Join("msg_application ma ON rt.rt_value::integer = ma.application_id").
                Join("msg_provider mp on mp.provider_id=mt.gateway::integer").
                GroupBy("mt.template_local_id", "mt.template_name", "mt.template_format", "mt.sender_id", "mt.entity_id",
                        "mt.template_id", "mt.message_type", "mp.provider_name", "mt.status_cd").
                OrderBy("mt.template_local_id").
                Limit(uint64(listTemplate.Limit)).
                Offset(uint64(listTemplate.Skip))

        // Execute the main query to fetch templates and total count
        templates, err := dblib.SelectRows(ctx, tr.Db, query, pgx.RowToStructByNameLax[domain.MaintainTemplate])
        if err != nil </span><span class="cov0" title="0">{
                log.Error(gctx, "DB Error in ListTemplatesLimit: %s", err.Error())
                return nil, 0, err
        }</span>

        // Fetch the total count using the subquery
        <span class="cov8" title="1">if len(templates) &gt; 0 </span><span class="cov8" title="1">{
                totalCount = templates[0].TotalCount
        }</span>

        // Return the templates and total count
        <span class="cov8" title="1">return templates, totalCount, nil</span>
}

func (tr *TemplateRepository) ToggleTemplateStatusRepo(gctx *gin.Context, msgtemplate *domain.StatusTemplate) (interface{}, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var Counter domain.Counter
        TxDB := tr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                // Check if data already exists
                query := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_template").
                        Where(squirrel.Eq{"template_local_id": msgtemplate.TemplateLocalID})
                err := dblib.TxReturnRow(ctx, tx, query, pgx.RowToStructByPos[domain.Counter], &amp;Counter)

                if err != nil </span><span class="cov0" title="0">{
                        log.Error(gctx, "Error checking whether a msg_template exists for the given template_local_id in StatusTemplate repo function: %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count == 0 </span><span class="cov0" title="0">{
                        return errors.New("no template with selected details is available")
                }</span>
                <span class="cov8" title="1">uquery := dblib.Psql.Update("msg_template").
                        Set("status_cd", squirrel.Expr("CASE WHEN status_cd = 0 THEN 1 ELSE 0 END")).
                        Where(squirrel.Eq{"template_local_id": msgtemplate.TemplateLocalID})
                err = dblib.TxExec(ctx, tx, uquery)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(gctx, "Error executing update query in StatusTemplate repo function: %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(gctx, "Transaction rolling back in Status Template repo function:  %s", TxDB.Error())
                return map[string]interface{}{}, TxDB
        }</span>
        <span class="cov8" title="1">return map[string]interface{}{}, nil</span>
}

/*
func (tr *TemplateRepository) GetTemplatebyID2(gctx *gin.Context, msgtemplate *domain.MaintainTemplate) ([]domain.MaintainTemplate, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var listTemplates []domain.MaintainTemplate

        TxDB := tr.Db.WithTx(ctx, func(tx pgx.Tx) error {
                query := dblib.Psql.Select("mt.template_local_id", "STRING_AGG(ma.application_name, ', ') AS application_id", "mt.template_name", "mt.template_format", "mt.sender_id", "mt.entity_id", "mt.template_id", "mt.gateway", "mt.status_cd").
                        From("msg_template mt").
                        Join("LATERAL unnest(string_to_array(mt.application_id, ',')) AS rt(rt_value) ON true").
                        Join("msg_application ma ON rt.rt_value::integer = ma.application_id").
                        Join("msg_provider mp on mp.provider_id=mt.gateway::integer").
                        Where(squirrel.Eq{"template_local_id": msgtemplate.TemplateLocalID}).
                        GroupBy("mt.template_local_id", "mt.template_name", "mt.template_format", "mt.sender_id", "mt.entity_id", "mt.template_id", "mp.provider_name", "mt.status_cd").
                        OrderBy("mt.template_local_id")

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.MaintainTemplate], &amp;listTemplates)
                if err != nil {
                        log.Error(gctx, "Error executing query in GetTemplatebyID repo function:  %s", err.Error())
                        return err
                }
                return nil
        })
        if TxDB != nil {
                log.Error(gctx, "Error initiating transaction in GetTemplatebyID repo function:  %s", TxDB.Error())
                return nil, TxDB
        }
        return listTemplates, nil
}
        */

func (tr *TemplateRepository) FetchTemplateRepo(gctx *gin.Context, msgtemplate *domain.MaintainTemplate) ([]domain.MaintainTemplate, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        query := dblib.Psql.Select("mt.template_local_id", "STRING_AGG(ma.application_name, ', ') AS application_id", "mt.template_name", "mt.template_format", "mt.sender_id", "mt.entity_id", "mt.template_id", "mt.message_type", "mt.gateway", "mt.status_cd").
                From("msg_template mt").
                Join("LATERAL unnest(string_to_array(mt.application_id, ',')) AS rt(rt_value) ON true").
                Join("msg_application ma ON rt.rt_value::integer = ma.application_id").
                Join("msg_provider mp on mp.provider_id=mt.gateway::integer").
                Where(squirrel.Eq{"template_local_id": msgtemplate.TemplateLocalID}).
                GroupBy("mt.template_local_id", "mt.template_name", "mt.template_format", "mt.sender_id", "mt.entity_id", "mt.template_id", "mt.message_type", "mp.provider_name", "mt.status_cd").
                OrderBy("mt.template_local_id")
        return dblib.SelectRows(ctx, tr.Db, query, pgx.RowToStructByNameLax[domain.MaintainTemplate])
}</span>

func (tr *TemplateRepository) UpdateTemplateRepo(gctx *gin.Context, msgtemplate *domain.MaintainTemplate) error <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var Counter domain.Counter
        TxDB := tr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                // Check if data already exists
                query := dblib.Psql.Select("COUNT(1) as count").
                        From("msg_template").
                        Where(squirrel.Eq{"template_local_id": msgtemplate.TemplateLocalID})
                err := dblib.TxReturnRow(ctx, tx, query, pgx.RowToStructByPos[domain.Counter], &amp;Counter)

                if err != nil </span><span class="cov0" title="0">{
                        log.Error(gctx, "Error checking whether a msg_template exists for the given template_local_id in EditTemplate repo function: %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">if Counter.Count == 0 </span><span class="cov0" title="0">{
                        return errors.New("template does not exists, cannot update")
                }</span>
                <span class="cov8" title="1">uquery := dblib.Psql.Update("msg_template").
                        Set("application_id", msgtemplate.ApplicationID).
                        Set("template_name", msgtemplate.TemplateName).
                        Set("template_format", msgtemplate.TemplateFormat).
                        Set("sender_id", msgtemplate.SenderID).
                        Set("entity_id", msgtemplate.EntityID).
                        Set("template_id", msgtemplate.TemplateID).
                        Set("gateway", msgtemplate.Gateway).
                        Set("message_type", msgtemplate.MessageType).
                        Set("status_cd", msgtemplate.Status).
                        Where(squirrel.Eq{"template_local_id": msgtemplate.TemplateLocalID})
                err = dblib.TxExec(ctx, tx, uquery)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(gctx, "Error executing update query in EditTemplate repo function: %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(gctx, "Transaction rolling back in EditTemplate repo function:  %s", TxDB.Error())
                return TxDB
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (tr *TemplateRepository) FetchTemplateByApplicationRepo(gctx *gin.Context, msgtemplate *domain.MaintainTemplate) ([]domain.GetTemplatebyAPPID, error) <span class="cov8" title="1">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var listTemplates []domain.GetTemplatebyAPPID

        TxDB := tr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov8" title="1">{
                query := dblib.Psql.Select("mt.template_local_id", "mt.template_name").
                        From("msg_template mt").
                        Join("LATERAL unnest(string_to_array(mt.application_id, ',')) AS rt(rt_value) ON true").
                        Join("msg_application ma ON rt.rt_value::integer = ma.application_id").
                        Join("msg_provider mp on mp.provider_id=mt.gateway::integer").
                        Where("mt.status_cd = 1").                                                               // Add condition for status=1
                        Where("ARRAY["+msgtemplate.ApplicationID+"]::integer[] @&gt; ARRAY[rt.rt_value::integer]"). // Check if given application_id exists in the array
                        GroupBy("mt.template_local_id", "mt.template_name").
                        OrderBy("mt.template_local_id")

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.GetTemplatebyAPPID], &amp;listTemplates)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(gctx, "Error executing query in GetTemplatenamesbyID repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(gctx, "Error initiating transaction in GetTemplatenamesbyID repo function:  %s", TxDB.Error())
                return nil, TxDB
        }</span>
        <span class="cov8" title="1">return listTemplates, nil</span>
}

/*
func (tr *TemplateRepository) GetTemplateformatbyID(gctx *gin.Context, msgtemplate *domain.MaintainTemplate) ([]domain.GetTemplateformatbyID, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var listTemplates []domain.GetTemplateformatbyID

        TxDB := tr.Db.WithTx(ctx, func(tx pgx.Tx) error {
                query := dblib.Psql.Select("template_local_id", "template_name", "template_format", "template_id", "entity_id", "sender_id", "message_type").
                        From("msg_template").
                        Where(squirrel.Eq{"template_local_id": msgtemplate.TemplateLocalID})

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.GetTemplateformatbyID], &amp;listTemplates)
                if err != nil {
                        log.Error(gctx, "Error executing query in GetTemplateformatbyID repo function:  %s", err.Error())
                        return err
                }
                return nil
        })
        if TxDB != nil {
                log.Error(gctx, "Error initiating transaction in GetTemplateformatbyID repo function:  %s", TxDB.Error())
                return nil, TxDB
        }
        return listTemplates, nil
}
        

func (tr *TemplateRepository) GetTemplateIDbyformatRepo(gctx *gin.Context, msgtemplate *domain.MaintainTemplate) ([]domain.GetTemplateIDbyformat, error) <span class="cov0" title="0">{

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var listTemplates []domain.GetTemplateIDbyformat

        TxDB := tr.Db.WithTx(ctx, func(tx pgx.Tx) error </span><span class="cov0" title="0">{
                query := dblib.Psql.Select("template_id").
                        From("msg_template").
                        Where(squirrel.Eq{"template_format": msgtemplate.TemplateFormat})

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.GetTemplateIDbyformat], &amp;listTemplates)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error(gctx, "Error executing query in GetTemplateIDbyformat repo function:  %s", err.Error())
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">if TxDB != nil </span><span class="cov0" title="0">{
                log.Error(gctx, "Error initiating transaction in GetTemplateIDbyformat repo function:  %s", TxDB.Error())
                return nil, TxDB
        }</span>
        <span class="cov0" title="0">return listTemplates, nil</span>
}

func (tr *TemplateRepository) GetSenderIDbyTemplateformat(gctx *gin.Context, msgtemplate *domain.MaintainTemplate) ([]domain.GetSenderIDbyTemplateformat, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var listTemplates []domain.GetSenderIDbyTemplateformat

        TxDB := tr.Db.WithTx(ctx, func(tx pgx.Tx) error {
                query := dblib.Psql.Select("sender_id").
                        From("msg_template").
                        Where(squirrel.Eq{"template_format": msgtemplate.TemplateFormat})

                err := dblib.TxRows(ctx, tx, query, pgx.RowToStructByNameLax[domain.GetSenderIDbyTemplateformat], &amp;listTemplates)
                if err != nil {
                        log.Error(gctx, "Error executing query in GetSenderIDbyTemplateformat repo function:  %s", err.Error())
                        return err
                }
                return nil
        })
        if TxDB != nil {
                log.Error(gctx, "Error initiating transaction in GetSenderIDbyTemplateformat repo function:  %s", TxDB.Error())
                return nil, TxDB
        }
        return listTemplates, nil
}
*/

func (tr *TemplateRepository) FetchTemplateDetailsRepo(gctx *gin.Context, msgtemplate *domain.MaintainTemplate) ([]domain.GetTemplateformatbyID, error) {

        ctx, cancel := context.WithTimeout(gctx.Request.Context(), tr.Cfg.GetDuration("db.querytimeoutlow"))
        defer cancel()

        var listTemplates []domain.GetTemplateformatbyID

        // Start building the query
        query := dblib.Psql.Select("template_local_id", "template_name", "template_format", "template_id", "entity_id", "sender_id", "message_type").
                From("msg_template")

        // Add conditions using multiple Where clauses
        if msgtemplate.TemplateLocalID != 0 {
                query = query.Where(squirrel.Eq{"te</span><span class="cov8" title="1">mplate_local_id": msgtemplate.TemplateLocalID})
        }
        i</span>f msgtemplate.ApplicationID != "" {
        <span class="cov8" title="1">        query = query.Where(squirrel.Eq{"a</span><span class="cov8" title="1">pplication_id": msgtemplate.ApplicationID})
        }
        i</span>f msgtemplate.TemplateFormat != "" {
        <span class="cov8" title="1">        query = query.Where(squirrel.Eq{"te</span><span class="cov8" title="1">mplate_format": msgtemplate.TemplateFormat})
        }

</span>        // Execute the transaction
        TxDB := tr.Db.WithTx(ctx, func(tx pgx.Tx) error {
        <span class="cov8" title="1">        err := dblib.TxRows(ctx, tx, query, pgx.RowToSt</span><span class="cov8" title="1">ructByNameLax[domain.GetTemplateformatbyID], &amp;listTemplates)
                if err != nil {
                        log.Error(gct</span><span class="cov0" title="0">x, "Error executing query in GetTemplateformatbyID repo function: %s", err.Error())
                        return err
                }
                r</span>eturn nil
        }<span class="cov8" title="1">)
</span>
        if TxDB != nil {
        <span class="cov8" title="1">        log.Error(gctx</span><span class="cov0" title="0">, "Error initiating transaction in GetTemplateformatbyID repo function: %s", TxDB.Error())
                return nil, TxDB
        }

</span>        return listTemplates, nil
}<span class="cov8" title="1">
</pre>
		
		<pre class="file" id="file23" style="display: none">package routes

import (
        handler "MgApplication/handler"
        "net/http"
        "sync/atomic"

        "github.com/gin-gonic/gin"
        swaggerFileMgApplication
        ginMgApplicationwagger"
        apierrors "MgApplication/api-errors"
        r "MgApplication/api-server"
)

var isShuttingDown atomic.Value

func init() <span class="cov8" title="1">{
        isShuttingDown.Store(false)
}</span>

// SetIsShuttingDown is an exported function that allows other packages to update the isShuttingDown value
func SetIsShuttingDown(shuttingDown bool) <span class="cov0" title="0">{
        isShuttingDown.Store(shuttingDown)
}</span>

func HealthCheckHandler(c *gin.Context) <span class="cov8" title="1">{
        shuttingDown := isShuttingDown.Load().(bool)
        if shuttingDown </span><span class="cov0" title="0">{
                // If the server is shutting down, respond with Service Unavailable
                c.JSON(http.StatusServiceUnavailable, gin.H{"status": "unhealthy"})
                return
        }</span>
        // If the server is not shutting down, respond with OK
        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{"status": "healthy"})</span>
}

func Routes(router *r.Router,
        msgappHandler *handler.MgApplicationHandler,
        appHandler *handler.ApplicationHandler,
        providerHandler *handler.ProviderHandler,
        templateHandler *handler.TemplateHandler,
        reportsHandler *handler.ReportsHandler,
) <span class="cov8" title="1">{

        router.NoRoute(func(c *gin.Context) </span><span class="cov8" title="1">{
                apierrors.HandleNoRouteError(c)
        }</span>)

        <span class="cov8" title="1">router.NoMethod(func(c *gin.Context) </span><span class="cov0" title="0">{
                apierrors.HandleNoMethodError(c)
        }</span>)

        //add subroutes.

        //healthz URL
        <span class="cov8" title="1">router.GET("/healthz", HealthCheckHandler)

        v1 := router.Group("/v1")
        </span><span class="cov8" title="1">{
                // Swagger
                v1.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

                Application := v1.Group("/applications") //.Use(authMiddleware(token))
                </span><span class="cov8" title="1">{
                        Application.POST("", appHandler.CreateMessageApplicationHandler)
                        Application.GET("", appHandler.ListMessageApplicationsHandler)
                        Application.GET("/:application-id", appHandler.FetchApplicationHandler)
                        Application.PUT("/:application-id", appHandler.UpdateMessageApplicationHandler)
                        Application.PUT("/:application-id/status", appHandler.ToggleApplicationStatusHandler)
                }</span>

                <span class="cov8" title="1">Provider := v1.Group("/sms-providers")
                </span><span class="cov8" title="1">{
                        Provider.POST("", providerHandler.CreateMessageProviderHandler)
                        Provider.GET("", providerHandler.ListMessageProvidersHandler)
                        Provider.GET("/:provider-id", providerHandler.FetchMessageProviderHandler)
                        Provider.PUT("/:provider-id", providerHandler.UpdateMessageProviderHandler)
                        Provider.PUT("/:provider-id/status", providerHandler.ToggleMessageProviderStatusHandler)
                }</span>

                <span class="cov8" title="1">Template := v1.Group("/sms-templates")
                </span><span class="cov8" title="1">{
                        Template.POST("", templateHandler.CreateTemplateHandler)
                        Template.GET("", templateHandler.ListTemplatesHandler)
                        Template.GET("/:template-local-id", templateHandler.FetchTemplateHandler)
                        Template.GET("/name", templateHandler.FetchTemplateByApplicationHandler) //by appID query param
                        Template.GET("/details", templateHandler.FetchTemplateDetailsHandler)    //takes query param, by template-format is yet to be tested
                        Template.PUT("/:template-local-id/status", templateHandler.ToggleTemplateStatusHandler)
                        Template.PUT("/:template-local-id", templateHandler.UpdateTemplateHandler)
                }</span>

                <span class="cov8" title="1">v1.POST("/sms-request", msgappHandler.CreateSMSRequestHandler)
                v1.POST("/test-sms-request", msgappHandler.CreateTestSMSHandler)

                //reports
                v1.GET("/sms-dashboard", reportsHandler.SMSDashboardHandler)
                v1.GET("/sms-sent-status-report", reportsHandler.SentSMSStatusReportHandler)
                v1.GET("/aggregate-sms-report", reportsHandler.AggregateSMSUsageReportHandler)

                v1.POST("/bulk-sms-initiate", msgappHandler.InitiateBulkSMSHandler)
                v1.GET("/bulk-sms-validate-otp", msgappHandler.ValidateTestSMSHandler)
                // v1.POST("/bulk-sms-upload-file", msgappHandler.BuildTargetFile) //not in use
                v1.POST("/bulk-sms", msgappHandler.SendBulkSMSHandler)</span>
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
